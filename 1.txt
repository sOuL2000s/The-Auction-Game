GEMINI_API_KEY="AIzaSyCzx6ReMk8ohPJcCjGwHHzu7SvFccJqAbA"

----------------------------

# Node.js dependencies
node_modules/

# Environment variables
.env

# Logs and temporary files
*.log
npm-debug.log*
.DS_Store # macOS specific
Thumbs.db # Windows specific
package-lock.json

----------------------------------------

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Grand Auction House</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="header">
        <h1>The Grand Auction House</h1>
    </div>

    <div id="message-area" class="message-area"></div>

    <div class="game-wrapper"> <!-- New wrapper for main content area -->
        <!-- Room Selection/Creation Area -->
        <div id="room-selection-area" class="room-selection-area">
            <div class="welcome-section">
                <h2>Welcome to the Auction!</h2>
                <p>Ready to create or join a game?</p>
            </div>
            <div class="room-actions-section">
                <div class="input-group">
                    <input type="text" id="roomIdInput" placeholder="Enter Room ID to Join">
                    <button id="joinRoomBtn" class="action-btn">Join Room</button>
                </div>
                <p class="or-divider">- OR -</p>
                <button id="createRoomBtn" class="action-btn create-room-btn">Create New Room (as Auctioneer)</button>
            </div>
        </div>

        <div class="game-container"> <!-- Existing game container for panels -->
            <aside class="player-panel" style="display: none;" id="playerPanel">
                <h2>Your Corner</h2>
                <p class="current-room-display">Current Room: <span id="playerRoomIdDisplay" class="room-id"></span></p>

                <div class="player-info card">
                    <p>Player ID: <span id="playerIdDisplay" class="player-id"></span></p>
                    <p>Your Display Name:</p>
                    <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
                    <button id="setPlayerNameBtn" class="action-btn">Set Name</button>
                    <p class="budget-display">Budget: $<span id="playerBudgetDisplay">0</span></p>
                </div>

                <h3>Current Auction</h3>
                <div id="player-current-auction" class="auction-display card">
                    <p class="item-name">Item: <span id="currentAuctionItemName">Awaiting Auction</span></p>
                    <p class="current-bid">Current Bid: $<span id="currentAuctionBid">0</span></p>
                    <p class="highest-bidder">Highest Bidder: <span id="currentHighestBidder">N/A</span></p>

                    <div id="bid-input-area" class="bid-input-area" style="display: none;">
                        <input type="number" id="bidAmountInput" placeholder="Your Bid" min="0">
                        <button id="placeBidBtn" class="bid-btn">Place Bid!</button>
                    </div>
                </div>

                <h3>Your Winnings</h3>
                <ul id="playerWonItemsList" class="item-list card">
                    <li class="placeholder-item">No items won yet.</li>
                </ul>

                <div class="llm-assistant-section card">
                    <h3>AI Assistant</h3>
                    <div id="playerLlmChat" class="llm-chat-window">
                        <div class="llm-messages" id="playerLlmMessages">
                            <p class="llm-message bot">Hello! Ask me anything about the auction rules or items.</p>
                        </div>
                        <div class="llm-input-area">
                            <input type="text" id="playerLlmInput" placeholder="Ask the AI...">
                            <button id="playerLlmSendBtn">Send</button>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="main-auction-area" style="display: none;" id="mainAuctionArea">
                <div id="auction-timer-display" class="auction-timer-display" style="display: none;">
                    Bidding Ends In: <span id="timer-countdown">00:00</span>
                </div>
                <div class="auction-hammer-effect" id="auctionHammerEffect">
                    <p>SOLD!</p>
                </div>
                <div id="central-auction-item" class="central-auction-item card">
                    <p class="status-message" id="centralStatusMessage">Auction awaits the Auctioneer.</p>
                </div>
            </main>

            <aside class="auctioneer-panel" style="display: none;" id="auctioneerPanel">
                <h2>Auctioneer's Podium</h2>
                <p class="current-room-display">Current Room: <span id="auctioneerRoomIdDisplay" class="room-id"></span></p>

                <div class="game-settings card">
                    <h3>Game Settings</h3>
                    <label for="startingBudgetInput">Player Starting Budget:</label>
                    <input type="number" id="startingBudgetInput" value="5000" min="100">

                    <label for="bidIncrementPercentInput">Min Bid Increment (%):</label>
                    <input type="number" id="bidIncrementPercentInput" value="5" min="1" max="100">

                    <label for="auctionDurationInput">Bidding Round Duration (s):</label>
                    <input type="number" id="auctionDurationInput" value="15" min="5" max="120">

                    <button id="updateSettingsBtn" class="action-btn">Update Settings</button>
                </div>

                <div class="item-management card">
                    <h3>Add New Treasure</h3>
                    <input type="text" id="itemNameInput" placeholder="Item Name">
                    <input type="number" id="itemBasePriceInput" placeholder="Base Price" min="0">
                    <button id="addItemBtn" class="action-btn">Add Item</button>

                    <h3>Batch Item Inclusion</h3>
                    <textarea id="batchItemsInput" rows="5" placeholder="Enter items (e.g., 'Painting,1500&#10;Statue,800') or upload CSV"></textarea>
                    <input type="file" id="batchCsvFileInput" accept=".csv">
                    <button id="addBatchItemsBtn" class="action-btn">Add Batch Items</button>
                </div>

                <h3>Current Auction Management</h3>
                <div id="auctioneer-current-item" class="auction-management card">
                    <p>No item currently selected for auction.</p>
                </div>
                <button id="startBiddingBtn" class="action-btn" style="display: none;">Start Bidding!</button>
                <button id="finalizeItemBtn" class="action-btn finalize-btn" style="display: none;">Finalize Auction</button>
                <button id="clearAuctionBtn" class="action-btn clear-btn" style="display: none;">Clear Current Auction</button>

                <h3>Available Items</h3>
                <ul id="auctioneerItemsList" class="item-list card">
                    <li class="placeholder-item">No items added yet.</li>
                </ul>

                <div class="llm-assistant-section card">
                    <h3>AI Assistant</h3>
                    <div id="auctioneerLlmChat" class="llm-chat-window">
                        <div class="llm-messages" id="auctioneerLlmMessages">
                            <p class="llm-message bot">Hello, Auctioneer! How may I assist you?</p>
                        </div>
                        <div class="llm-input-area">
                            <input type="text" id="auctioneerLlmInput" placeholder="Ask the AI...">
                            <button id="auctioneerLlmSendBtn">Send</button>
                        </div>
                    </div>
                </div>
            </aside>
        </div> <!-- End .game-container -->
    </div> <!-- End .game-wrapper -->

    <audio id="bidSound" src="https://www.soundjay.com/buttons/sounds/button-2.mp3" preload="auto"></audio>
    <audio id="hammerSound" src="https://www.soundjay.com/misc/sounds/hammer.mp3" preload="auto"></audio>
    <script src="script.js"></script>
</body>
</html>

-----------------------------------

{
  "name": "the-auctionaire-game",
  "version": "1.0.0",
  "main": "script.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "uuid": "^13.0.0",
    "ws": "^8.18.3"
  }
}

--------------------------------

document.addEventListener('DOMContentLoaded', () => {
    // --- WebSocket Setup ---
    // For deployment: use wss and actual host
    const PROTOCOL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const HOST = window.location.host; // Use current host for deployment
    const socket = new WebSocket(`${PROTOCOL}//${HOST}`);

    // --- UI Elements ---
    const messageArea = document.getElementById('message-area');
    const bidSound = document.getElementById('bidSound');
    const hammerSound = document.getElementById('hammerSound');
    const auctionHammerEffect = document.getElementById('auctionHammerEffect');

    // Room Selection Elements
    const roomSelectionArea = document.getElementById('room-selection-area');
    const roomIdInput = document.getElementById('roomIdInput');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const createRoomBtn = document.getElementById('createRoomBtn');

    // Main Game Panels
    const playerPanel = document.getElementById('playerPanel');
    const mainAuctionArea = document.getElementById('mainAuctionArea');
    const auctioneerPanel = document.getElementById('auctioneerPanel');

    // Auctioneer Elements
    const auctioneerRoomIdDisplay = document.getElementById('auctioneerRoomIdDisplay');
    const itemNameInput = document.getElementById('itemNameInput');
    const itemBasePriceInput = document.getElementById('itemBasePriceInput');
    const addItemBtn = document.getElementById('addItemBtn');
    const auctioneerCurrentItemDiv = document.getElementById('auctioneer-current-item');
    const startBiddingBtn = document.getElementById('startBiddingBtn');
    const finalizeItemBtn = document.getElementById('finalizeItemBtn');
    const clearAuctionBtn = document.getElementById('clearAuctionBtn');
    const auctioneerItemsList = document.getElementById('auctioneerItemsList');
    // Auctioneer Batch Items
    const batchItemsInput = document.getElementById('batchItemsInput');
    const batchCsvFileInput = document.getElementById('batchCsvFileInput');
    const addBatchItemsBtn = document.getElementById('addBatchItemsBtn');

    // Auctioneer Settings
    const startingBudgetInput = document.getElementById('startingBudgetInput');
    const bidIncrementPercentInput = document.getElementById('bidIncrementPercentInput');
    const auctionDurationInput = document.getElementById('auctionDurationInput');
    const updateSettingsBtn = document.getElementById('updateSettingsBtn');

    // Player Elements
    const playerRoomIdDisplay = document.getElementById('playerRoomIdDisplay');
    const playerIdDisplay = document.getElementById('playerIdDisplay');
    const playerNameInput = document.getElementById('playerNameInput');
    const setPlayerNameBtn = document.getElementById('setPlayerNameBtn');
    const playerBudgetDisplay = document.getElementById('playerBudgetDisplay');
    const currentAuctionItemName = document.getElementById('currentAuctionItemName');
    const currentAuctionBid = document.getElementById('currentAuctionBid');
    const currentHighestBidder = document.getElementById('currentHighestBidder');
    const bidInputArea = document.getElementById('bid-input-area');
    const bidAmountInput = document.getElementById('bidAmountInput');
    const placeBidBtn = document.getElementById('placeBidBtn');
    const playerWonItemsList = document.getElementById('playerWonItemsList');

    // Central Auction Display
    const centralAuctionItemDiv = document.getElementById('central-auction-item');
    const centralStatusMessage = document.getElementById('centralStatusMessage');
    const auctionTimerDisplay = document.getElementById('auction-timer-display');
    const timerCountdown = document.getElementById('timer-countdown');

    // LLM Assistant Elements
    const playerLlmMessages = document.getElementById('playerLlmMessages');
    const playerLlmInput = document.getElementById('playerLlmInput');
    const playerLlmSendBtn = document.getElementById('playerLlmSendBtn');
    const auctioneerLlmMessages = document.getElementById('auctioneerLlmMessages');
    const auctioneerLlmInput = document.getElementById('auctioneerLlmInput');
    const auctioneerLlmSendBtn = document.getElementById('auctioneerLlmSendBtn');


    // --- Game State Variables (Client-side) ---
    let myClientId = null; // This client's unique WS ID
    let myPlayerId = null; // This client's in-game player ID (if registered as player)
    let myRole = 'guest'; // 'guest', 'player', 'auctioneer'
    let currentRoomId = null;
    let myPlayerBudget = 0;
    let currentAuctionState = {}; // To hold the full game state for the current room from server


    // --- Helper Functions ---
    function showMessage(message, type = 'info') {
        messageArea.textContent = message;
        messageArea.className = `message-area show ${type}`;
        setTimeout(() => {
            messageArea.classList.remove('show');
        }, 5000);
    }

    function playSound(audioElement) {
        if (audioElement && audioElement.readyState >= 2) { // Check if sound is loaded
            audioElement.currentTime = 0; // Rewind to start
            audioElement.play().catch(e => console.warn("Audio play failed:", e));
        }
    }

    function addLlmMessage(chatWindow, message, sender = 'bot') {
        const p = document.createElement('p');
        p.classList.add('llm-message', sender);
        p.textContent = message;
        chatWindow.appendChild(p);
        chatWindow.scrollTop = chatWindow.scrollHeight; // Auto-scroll to bottom
    }

    function resetUI() {
        roomSelectionArea.style.display = 'flex';
        playerPanel.style.display = 'none';
        mainAuctionArea.style.display = 'none';
        auctioneerPanel.style.display = 'none';

        // Clear existing game state/UI elements
        myClientId = null;
        myPlayerId = null;
        myRole = 'guest';
        currentRoomId = null;
        myPlayerBudget = 0;
        currentAuctionState = {};

        // Reset specific UI elements
        roomIdInput.value = '';
        playerRoomIdDisplay.textContent = '';
        auctioneerRoomIdDisplay.textContent = '';
        playerIdDisplay.textContent = '';
        playerNameInput.value = '';
        playerBudgetDisplay.textContent = '0';
        currentAuctionItemName.textContent = 'Awaiting Auction';
        currentAuctionBid.textContent = '0';
        currentHighestBidder.textContent = 'N/A';
        bidInputArea.style.display = 'none';
        playerWonItemsList.innerHTML = '<li class="placeholder-item">No items won yet.</li>';
        auctioneerItemsList.innerHTML = '<li class="placeholder-item">No items added yet.</li>';
        centralAuctionItemDiv.innerHTML = '<p class="status-message" id="centralStatusMessage">Auction awaits the Auctioneer.</p>';
        auctionTimerDisplay.style.display = 'none';
        timerCountdown.textContent = '00:00';

        // Reset LLM chat windows
        playerLlmMessages.innerHTML = '<p class="llm-message bot">Hello! Ask me anything about the auction rules or items.</p>';
        auctioneerLlmMessages.innerHTML = '<p class="llm-message bot">Hello, Auctioneer! How may I assist you?</p>';

        // Re-enable initial buttons
        joinRoomBtn.disabled = false;
        createRoomBtn.disabled = false;
    }


    // --- WebSocket Event Handlers ---
    socket.onopen = () => {
        console.log('Connected to WebSocket server');
        showMessage('Connected to The Grand Auction House server.', 'success');
        resetUI(); // Show room selection initially

        // Try to re-establish session from localStorage if available
        const storedRoomId = localStorage.getItem('roomId');
        const storedPlayerId = localStorage.getItem('playerId');
        const storedPlayerName = localStorage.getItem('playerName');
        const storedRole = localStorage.getItem('role');

        if (storedRoomId && storedPlayerId && storedRole) {
            console.log(`Attempting to rejoin room ${storedRoomId} as ${storedRole} with ID ${storedPlayerId}`);
            socket.send(JSON.stringify({
                type: 'reconnect_session',
                roomId: storedRoomId,
                clientId: storedPlayerId, // This is actually client's ws.id
                playerName: storedPlayerName,
                role: storedRole
            }));
        } else {
            console.log("No stored session found, showing room selection.");
            roomSelectionArea.style.display = 'flex';
        }
    };

    socket.onmessage = (event) => {
        const message = JSON.parse(event.data);
        console.log('Received:', message);

        switch (message.type) {
            case 'client_id_assigned':
                myClientId = message.id; // Store client's unique WS ID
                console.log("My client ID is:", myClientId);
                break;

            case 'room_created':
                currentRoomId = message.roomId;
                myRole = 'auctioneer'; // The creator is automatically the auctioneer
                localStorage.setItem('roomId', currentRoomId);
                localStorage.setItem('role', myRole);
                showMessage(`Room "${currentRoomId}" created! You are the Auctioneer.`, 'success');
                displayGameUI();
                break;

            case 'joined_room':
                currentRoomId = message.roomId;
                myRole = message.role;
                myPlayerId = message.playerId; // This is the in-game player ID
                myPlayerBudget = message.budget;
                localStorage.setItem('roomId', currentRoomId);
                localStorage.setItem('playerId', myPlayerId);
                localStorage.setItem('playerName', message.playerName);
                localStorage.setItem('role', myRole);

                if (myRole === 'player') {
                    playerIdDisplay.textContent = myPlayerId.substring(0, 8);
                    playerNameInput.value = message.playerName || `Player ${myPlayerId.substring(0, 8)}`;
                    playerBudgetDisplay.textContent = myPlayerBudget.toLocaleString();
                } else if (myRole === 'auctioneer') {
                    // Auctioneer UI will be updated by auction_state_update
                }

                showMessage(`Joined room "${currentRoomId}" as ${myRole === 'auctioneer' ? 'Auctioneer' : 'Player'}!`, 'success');
                displayGameUI();
                break;

            case 'reconnected_session':
                currentRoomId = message.roomId;
                myRole = message.role;
                myPlayerId = message.playerId;
                myPlayerBudget = message.budget;
                localStorage.setItem('roomId', currentRoomId);
                localStorage.setItem('playerId', myPlayerId);
                localStorage.setItem('playerName', message.playerName);
                localStorage.setItem('role', myRole);

                if (myRole === 'player') {
                    playerIdDisplay.textContent = myPlayerId.substring(0, 8);
                    playerNameInput.value = message.playerName || `Player ${myPlayerId.substring(0, 8)}`;
                    playerBudgetDisplay.textContent = myPlayerBudget.toLocaleString();
                }
                showMessage(`Reconnected to room "${currentRoomId}" as ${message.playerName || myRole}!`, 'info');
                displayGameUI();
                break;

            case 'room_full':
            case 'room_not_found':
            case 'already_in_room':
            case 'auctioneer_exists':
                showMessage(message.message, 'error');
                // Stay on room selection screen
                roomSelectionArea.style.display = 'flex';
                break;

            case 'item_added':
                updateAuctioneerItems(message.items);
                if (auctioneerItemsList.querySelector('.placeholder-item')) auctioneerItemsList.innerHTML = '';
                showMessage(`"${message.item.name}" added to the inventory.`, 'info');
                break;
            case 'batch_items_added':
                updateAuctioneerItems(message.items);
                if (auctioneerItemsList.querySelector('.placeholder-item')) auctioneerItemsList.innerHTML = '';
                showMessage(`${message.count} items added to the inventory.`, 'success');
                break;

            case 'auction_state_update':
                currentAuctionState = message.state; // Update local state copy for the current room
                updateAuctionDisplay(message.state);
                updateCentralAuctionDisplay(message.state);
                updateAuctioneerItems(message.state.items); // Refresh auctioneer's item list
                updateTimerDisplay(message.state.timer); // Update timer
                break;
            case 'player_bid_update':
                currentAuctionState = message.auctionState; // Update local state copy
                updateAuctionDisplay(message.auctionState, true); // Trigger bid animation
                updateCentralAuctionDisplay(message.auctionState, true); // Trigger bid animation
                if (myPlayerId && message.playerId === myPlayerId) {
                    myPlayerBudget = message.playerBudget;
                    playerBudgetDisplay.textContent = myPlayerBudget.toLocaleString();
                }
                if (message.message) {
                    showMessage(message.message, message.success ? 'success' : 'error');
                }
                playSound(bidSound); // Play bid sound
                updateTimerDisplay(message.auctionState.timer); // Update timer
                break;
            case 'item_finalized':
                currentAuctionState = message.auctionState; // Update local state copy
                updateAuctionDisplay(message.auctionState);
                updateCentralAuctionDisplay(message.auctionState);
                updateAuctioneerItems(message.auctionState.items);
                updateTimerDisplay(message.auctionState.timer); // Reset timer display
                if (myPlayerId && message.winnerId === myPlayerId) {
                    if (playerWonItemsList.querySelector('.placeholder-item')) playerWonItemsList.innerHTML = '';
                    playerWonItemsList.innerHTML += `<li><span class="item-name">${message.item.name}</span> <span class="item-price">($${message.finalBid.toLocaleString()})</span></li>`;
                }
                showMessage(`${message.item.name} SOLD! Winner: ${message.winnerName || message.winnerId.substring(0,8)} for $${message.finalBid.toLocaleString()}!`, 'success');
                playSound(hammerSound);
                triggerHammerEffect();
                break;
            case 'auction_cleared':
                currentAuctionState = message.auctionState; // Update local state copy
                updateAuctionDisplay(message.auctionState);
                updateCentralAuctionDisplay(message.auctionState);
                updateAuctioneerItems(message.auctionState.items);
                updateTimerDisplay(message.auctionState.timer); // Reset timer display
                showMessage('Auction cleared by the Auctioneer.', 'info');
                break;
            case 'settings_updated':
                currentAuctionState.gameSettings = message.settings;
                showMessage('Game settings updated by Auctioneer.', 'info');
                // If auctioneer, update inputs to reflect new settings
                if(myRole === 'auctioneer') {
                    startingBudgetInput.value = currentAuctionState.gameSettings.playerStartingBudget;
                    bidIncrementPercentInput.value = currentAuctionState.gameSettings.minBidIncrementPercentage;
                    auctionDurationInput.value = currentAuctionState.gameSettings.auctionRoundDuration;
                }
                break;

            case 'llm_response':
                if (message.clientId === myClientId) { // Only show response to the client who asked
                    const targetChatWindow = myRole === 'auctioneer' ? auctioneerLlmMessages : playerLlmMessages;
                    addLlmMessage(targetChatWindow, message.response, 'bot');
                }
                break;

            case 'error':
                showMessage(message.message, 'error');
                break;
            case 'info':
                showMessage(message.message, 'info');
                break;
        }
    };

    socket.onclose = () => {
        console.log('Disconnected from WebSocket server');
        showMessage('Disconnected from auction server. Please restart the server or check connection.', 'error');
        // Disable all controls
        [joinRoomBtn, createRoomBtn, setPlayerNameBtn, addItemBtn, startBiddingBtn, finalizeItemBtn, clearAuctionBtn, placeBidBtn, updateSettingsBtn, addBatchItemsBtn, playerLlmSendBtn, auctioneerLlmSendBtn].forEach(btn => btn.disabled = true);
        auctionTimerDisplay.style.display = 'none'; // Hide timer on disconnect
        // Clear local storage for a fresh start next time
        localStorage.removeItem('roomId');
        localStorage.removeItem('playerId');
        localStorage.removeItem('playerName');
        localStorage.removeItem('role');
        resetUI(); // Show room selection (disabled)
    };

    socket.onerror = (error) => {
        console.error('WebSocket Error:', error);
        showMessage('WebSocket connection error. Is the server running?', 'error');
    };


    // --- UI Display Management ---
    function displayGameUI() {
        roomSelectionArea.style.display = 'none';
        playerPanel.style.display = 'flex'; // Players always see their panel
        mainAuctionArea.style.display = 'flex'; // Everyone sees the main auction area

        if (myRole === 'auctioneer') {
            auctioneerPanel.style.display = 'flex';
            auctioneerRoomIdDisplay.textContent = currentRoomId;
            // Ensure auctioneer settings reflect current game state
            if (currentAuctionState.gameSettings) {
                startingBudgetInput.value = currentAuctionState.gameSettings.playerStartingBudget;
                bidIncrementPercentInput.value = currentAuctionState.gameSettings.minBidIncrementPercentage;
                auctionDurationInput.value = currentAuctionState.gameSettings.auctionRoundDuration;
            }
        } else {
            auctioneerPanel.style.display = 'none';
        }

        playerRoomIdDisplay.textContent = currentRoomId;
    }

    function updateAuctioneerItems(items) {
        auctioneerItemsList.innerHTML = '';
        if (items.length === 0) {
            auctioneerItemsList.innerHTML = '<li class="placeholder-item">No items added yet.</li>';
            return;
        }
        items.forEach(item => {
            const li = document.createElement('li');
            li.classList.add('item-row');
            if (item.status === 'auctioning') {
                li.classList.add('current-auction-item');
            } else if (item.status === 'sold') {
                li.classList.add('sold-item');
            }

            li.innerHTML = `
                <span class="item-details">${item.name} - Base: $${item.basePrice.toLocaleString()} </span>
                <span class="item-status">${item.status === 'pending' ? ' (Ready)' : item.status === 'auctioning' ? ' (LIVE!)' : ' (SOLD)'}</span>
                ${myRole === 'auctioneer' && item.status === 'pending' ? `<button class="select-item-btn action-btn" data-item-id="${item.id}">Select for Auction</button>` : ''}
            `;
            auctioneerItemsList.appendChild(li);
        });
    }

    function updateAuctionDisplay(state, isNewBid = false) {
        // Player View
        const itemName = state.currentAuctionItem ? state.currentAuctionItem.name : 'Awaiting Auction';
        const currentBid = state.currentHighestBid;
        const highestBidderName = state.currentHighestBidder ? (state.players[state.currentHighestBidder]?.name || state.currentHighestBidder.substring(0,8)) : 'N/A';

        currentAuctionItemName.textContent = itemName;
        currentAuctionBid.textContent = currentBid.toLocaleString();
        currentHighestBidder.textContent = highestBidderName;

        if (state.auctionState === 'bidding' && myPlayerId) {
            bidInputArea.style.display = 'block';
            placeBidBtn.disabled = false;
            // Set min bid value
            const minBidValue = Math.ceil(currentBid * (1 + state.gameSettings.minBidIncrementPercentage / 100));
            bidAmountInput.min = minBidValue;
            if (parseFloat(bidAmountInput.value) < minBidValue || bidAmountInput.value === '') {
                bidAmountInput.value = minBidValue;
            }
        } else {
            bidInputArea.style.display = 'none';
        }

        if (isNewBid) {
            currentAuctionBid.classList.add('new-bid-effect');
            setTimeout(() => {
                currentAuctionBid.classList.remove('new-bid-effect');
            }, 300);
        }

        // Auctioneer View
        if (myRole === 'auctioneer') {
            if (state.currentAuctionItem) {
                auctioneerCurrentItemDiv.innerHTML = `
                    <p class="current-auction-item">
                        <strong>Current Item: ${state.currentAuctionItem.name}</strong><br>
                        Base Price: $${state.currentAuctionItem.basePrice.toLocaleString()}<br>
                        Current Bid: $${state.currentHighestBid.toLocaleString()}<br>
                        Highest Bidder: ${highestBidderName}<br>
                        Status: ${state.auctionState === 'bidding' ? 'Bidding In Progress' : 'Item Selected, Awaiting Bid Start'}
                    </p>
                `;
                finalizeItemBtn.style.display = (state.auctionState === 'bidding' && state.currentHighestBidder) ? 'inline-block' : 'none';
                startBiddingBtn.style.display = (state.auctionState === 'item_selected' && state.currentAuctionItem) ? 'inline-block' : 'none';
                clearAuctionBtn.style.display = (state.auctionState !== 'idle') ? 'inline-block' : 'none';
            } else {
                auctioneerCurrentItemDiv.innerHTML = '<p>No item currently selected for auction.</p>';
                startBiddingBtn.style.display = 'none';
                finalizeItemBtn.style.display = 'none';
                clearAuctionBtn.style.display = 'none';
            }
        }
    }

    function updateCentralAuctionDisplay(state, isNewBid = false) {
        if (!state.currentAuctionItem) {
            centralAuctionItemDiv.innerHTML = `<p class="status-message" id="centralStatusMessage">Auction awaits the Auctioneer.</p>`;
            return;
        }

        const itemName = state.currentAuctionItem.name;
        const currentBid = state.currentHighestBid;
        const highestBidderName = state.currentHighestBidder ? (state.players[state.currentHighestBidder]?.name || state.currentHighestBidder.substring(0,8)) : 'N/A';

        centralAuctionItemDiv.innerHTML = `
            <h3>${itemName}</h3>
            <p>Base Price: $${state.currentAuctionItem.basePrice.toLocaleString()}</p>
            <p class="central-bid">Current Bid: $<span id="centralCurrentBidValue">${currentBid.toLocaleString()}</span></p>
            <p class="central-highest-bidder">Highest Bidder: ${highestBidderName}</p>
            <p class="status-message">${state.auctionState === 'bidding' ? 'Bidding Live!' : 'Item Selected'}</p>
        `;

        if (isNewBid) {
            const centralBidElement = centralAuctionItemDiv.querySelector('.central-bid');
            if (centralBidElement) {
                centralBidElement.classList.add('new-bid-effect');
                setTimeout(() => {
                    centralBidElement.classList.remove('new-bid-effect');
                }, 300);
            }
        }
    }

    function updateTimerDisplay(timerData) {
        if (timerData && timerData.active && currentAuctionState.auctionState === 'bidding') {
            auctionTimerDisplay.style.display = 'flex';
            const remaining = Math.max(0, Math.floor((timerData.endTime - Date.now()) / 1000));
            const minutes = Math.floor(remaining / 60).toString().padStart(2, '0');
            const seconds = (remaining % 60).toString().padStart(2, '0');
            timerCountdown.textContent = `${minutes}:${seconds}`;

            if (remaining <= 5 && remaining > 0) {
                auctionTimerDisplay.classList.add('time-low');
            } else {
                auctionTimerDisplay.classList.remove('time-low');
            }
        } else {
            auctionTimerDisplay.style.display = 'none';
            auctionTimerDisplay.classList.remove('time-low');
        }
    }

    function triggerHammerEffect() {
        auctionHammerEffect.classList.add('show');
        setTimeout(() => {
            auctionHammerEffect.classList.remove('show');
        }, 1500); // Duration of the effect
    }

    // --- Event Listeners ---

    // Room Actions
    createRoomBtn.addEventListener('click', () => {
        socket.send(JSON.stringify({ type: 'create_room', clientId: myClientId }));
    });

    joinRoomBtn.addEventListener('click', () => {
        const roomId = roomIdInput.value.trim();
        if (roomId) {
            socket.send(JSON.stringify({ type: 'join_room', roomId: roomId, clientId: myClientId }));
        } else {
            showMessage('Please enter a Room ID.', 'error');
        }
    });


    // Player Actions
    setPlayerNameBtn.addEventListener('click', () => {
        const name = playerNameInput.value.trim();
        if (name && myPlayerId && currentRoomId) {
            socket.send(JSON.stringify({ type: 'set_player_name', roomId: currentRoomId, playerId: myPlayerId, name }));
            localStorage.setItem('playerName', name);
            showMessage(`Your display name set to "${name}".`, 'info');
        } else {
            showMessage('Please enter a valid display name.', 'error');
        }
    });

    placeBidBtn.addEventListener('click', () => {
        const bidAmount = parseFloat(bidAmountInput.value);
        const minBid = parseFloat(bidAmountInput.min);

        if (!currentRoomId || !myPlayerId) {
            showMessage('You are not in a game room or not registered as a player.', 'error');
            return;
        }

        if (isNaN(bidAmount) || bidAmount < minBid) {
            showMessage(`Bid must be at least $${minBid.toLocaleString()}.`, 'error');
            return;
        }
        socket.send(JSON.stringify({ type: 'place_bid', roomId: currentRoomId, playerId: myPlayerId, bidAmount }));
    });

    // Auctioneer Actions
    updateSettingsBtn.addEventListener('click', () => {
        if (!currentRoomId || myRole !== 'auctioneer') {
            showMessage('Only the auctioneer in an active room can update settings.', 'error');
            return;
        }
        const playerStartingBudget = parseFloat(startingBudgetInput.value);
        const minBidIncrementPercentage = parseFloat(bidIncrementPercentInput.value);
        const auctionRoundDuration = parseInt(auctionDurationInput.value);

        if (isNaN(playerStartingBudget) || playerStartingBudget < 100 ||
            isNaN(minBidIncrementPercentage) || minBidIncrementPercentage < 1 || minBidIncrementPercentage > 100 ||
            isNaN(auctionRoundDuration) || auctionRoundDuration < 5 || auctionRoundDuration > 120) {
            showMessage('Please enter valid settings: Budget (min 100), Increment (1-100%), Duration (5-120s).', 'error');
            return;
        }

        socket.send(JSON.stringify({
            type: 'update_settings',
            roomId: currentRoomId,
            settings: {
                playerStartingBudget,
                minBidIncrementPercentage,
                auctionRoundDuration
            }
        }));
    });

    addItemBtn.addEventListener('click', () => {
        if (!currentRoomId || myRole !== 'auctioneer') {
            showMessage('Only the auctioneer in an active room can add items.', 'error');
            return;
        }
        const name = itemNameInput.value.trim();
        const basePrice = parseFloat(itemBasePriceInput.value);
        if (name && !isNaN(basePrice) && basePrice >= 0) {
            socket.send(JSON.stringify({ type: 'add_item', roomId: currentRoomId, name, basePrice }));
            itemNameInput.value = '';
            itemBasePriceInput.value = '';
        } else {
            showMessage('Please enter a valid item name and base price.', 'error');
        }
    });

    auctioneerItemsList.addEventListener('click', (event) => {
        if (!currentRoomId || myRole !== 'auctioneer') return; // Must be auctioneer in a room
        if (event.target.classList.contains('select-item-btn')) {
            const itemId = event.target.dataset.itemId;
            socket.send(JSON.stringify({ type: 'select_item_for_auction', roomId: currentRoomId, itemId }));
        }
    });

    startBiddingBtn.addEventListener('click', () => {
        if (!currentRoomId || myRole !== 'auctioneer') return; // Must be auctioneer in a room
        socket.send(JSON.stringify({ type: 'start_bidding', roomId: currentRoomId }));
    });

    finalizeItemBtn.addEventListener('click', () => {
        if (!currentRoomId || myRole !== 'auctioneer') return; // Must be auctioneer in a room
        socket.send(JSON.stringify({ type: 'finalize_item', roomId: currentRoomId }));
    });

    clearAuctionBtn.addEventListener('click', () => {
        if (!currentRoomId || myRole !== 'auctioneer') return; // Must be auctioneer in a room
        socket.send(JSON.stringify({ type: 'clear_auction', roomId: currentRoomId }));
    });

    // Batch Item Inclusion
    addBatchItemsBtn.addEventListener('click', () => {
        if (!currentRoomId || myRole !== 'auctioneer') {
            showMessage('Only the auctioneer in an active room can add items.', 'error');
            return;
        }

        let rawData = batchItemsInput.value.trim();
        const file = batchCsvFileInput.files[0];

        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                rawData = e.target.result;
                sendBatchItems(rawData);
            };
            reader.onerror = () => {
                showMessage('Error reading file.', 'error');
            };
            reader.readAsText(file);
        } else if (rawData) {
            sendBatchItems(rawData);
        } else {
            showMessage('Please enter raw item data or select a CSV file.', 'error');
        }
    });

    function sendBatchItems(data) {
        // Simple client-side validation/parsing for immediate feedback
        const items = data.split('\n').map(line => {
            const parts = line.split(',').map(p => p.trim());
            if (parts.length >= 2) {
                const name = parts[0];
                const basePrice = parseFloat(parts[1]);
                if (name && !isNaN(basePrice) && basePrice >= 0) {
                    return { name, basePrice };
                }
            }
            return null;
        }).filter(item => item !== null);

        if (items.length > 0) {
            socket.send(JSON.stringify({ type: 'add_batch_items', roomId: currentRoomId, items }));
            batchItemsInput.value = '';
            batchCsvFileInput.value = ''; // Clear file input
        } else {
            showMessage('No valid items found in the input. Format: "Name,Price" per line.', 'error');
        }
    }


    // LLM Assistant Listeners
    playerLlmSendBtn.addEventListener('click', () => {
        const query = playerLlmInput.value.trim();
        if (query && currentRoomId) {
            addLlmMessage(playerLlmMessages, query, 'user');
            socket.send(JSON.stringify({ type: 'llm_query', roomId: currentRoomId, query, clientId: myClientId, role: myRole }));
            playerLlmInput.value = '';
        }
    });
    playerLlmInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') playerLlmSendBtn.click();
    });

    auctioneerLlmSendBtn.addEventListener('click', () => {
        const query = auctioneerLlmInput.value.trim();
        if (query && currentRoomId) {
            addLlmMessage(auctioneerLlmMessages, query, 'user');
            socket.send(JSON.stringify({ type: 'llm_query', roomId: currentRoomId, query, clientId: myClientId, role: myRole }));
            auctioneerLlmInput.value = '';
        }
    });
    auctioneerLlmInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') auctioneerLlmSendBtn.click();
    });

    // Initial population for placeholder lists
    if (playerWonItemsList.innerHTML === '') {
        playerWonItemsList.innerHTML = '<li class="placeholder-item">No items won yet.</li>';
    }
    if (auctioneerItemsList.innerHTML === '') {
        auctioneerItemsList.innerHTML = '<li class="placeholder-item">No items added yet.</li>';
    }
});

-----------------------------------------------------

const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const path = require('path');
const dotenv = require('dotenv');

// Load environment variables from .env file
dotenv.config();

// Access the API key securely
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
// Corrected model name to a stable 'flash' variant.
const GEMINI_MODEL_NAME = "gemini-2.5-flash-preview-05-20";

let uuidv4;
let GoogleGenerativeAI;

(async () => {
    try {
        const uuidModule = await import('uuid');
        uuidv4 = uuidModule.v4;

        const generativeAIModule = await import('@google/generative-ai');
        GoogleGenerativeAI = generativeAIModule.GoogleGenerativeAI;

        if (!GEMINI_API_KEY) {
            console.warn("GEMINI_API_KEY is not set. Please set it in your .env file or environment variables.");
            // Do NOT exit here, as the game can still run without AI.
            // Just ensure model is null so AI functions are skipped.
        }

    } catch (error) {
        console.error("Failed to load critical modules or environment variables:");
        console.error(error);
        process.exit(1);
    }

    const app = express();
    const server = http.createServer(app);
    const wss = new WebSocket.Server({ server });

    const PORT = process.env.PORT || 3000;

    app.use(express.static(__dirname));

    const gameRooms = {};

    const DEFAULT_GAME_SETTINGS = {
        playerStartingBudget: 5000,
        minBidIncrementPercentage: 5,
        auctionRoundDuration: 15
    };

    // --- Helper Functions ---

    function generateRoomId() {
        let roomId;
        do {
            roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
        } while (gameRooms[roomId]);
        return roomId;
    }

    function createNewGameState() {
        return {
            items: [],
            players: {}, // Stores player objects, including their WebSocket (ws) reference
            auctioneerWsId: null, // Stores the ws.id of the current auctioneer
            currentAuctionItem: null,
            currentHighestBid: 0,
            currentHighestBidder: null,
            auctionState: 'idle',
            timer: {
                active: false,
                endTime: 0,
                interval: null // This stores the Node.js Timeout object, which is circular
            },
            gameSettings: { ...DEFAULT_GAME_SETTINGS }
        };
    }

    // Helper to create a clean state object for broadcasting/sending to clients,
    // removing circular references and server-only data.
    function getCleanGameStateForClient(gameState) {
        // Explicitly build a new object with only serializable data
        const cleanState = {
            items: gameState.items.map(item => ({ ...item })), // Deep copy items
            currentAuctionItem: gameState.currentAuctionItem ? { ...gameState.currentAuctionItem } : null,
            currentHighestBid: gameState.currentHighestBid,
            currentHighestBidder: gameState.currentHighestBidder,
            auctionState: gameState.auctionState,
            gameSettings: { ...gameState.gameSettings }, // Shallow copy settings
            // Timer only needs active and endTime, not the circular interval object
            timer: {
                active: gameState.timer.active,
                endTime: gameState.timer.endTime
            },
            // Players need special handling to exclude the WebSocket object reference
            players: {}
        };

        for (const playerId in gameState.players) {
            const player = gameState.players[playerId];
            cleanState.players[playerId] = {
                name: player.name,
                budget: player.budget,
                wonItems: player.wonItems.map(item => ({ ...item })), // Deep copy wonItems
                // Explicitly EXCLUDE the 'ws' (WebSocket) object
            };
        }

        return cleanState;
    }

    function broadcastToRoom(roomId, message) {
        if (!gameRooms[roomId]) return;

        // If the message contains gameState, sanitize it before sending
        let messageToSend = { ...message }; // Shallow copy of the message object
        if (messageToSend.state) {
            messageToSend.state = getCleanGameStateForClient(messageToSend.state);
        } else if (messageToSend.auctionState) {
            messageToSend.auctionState = getCleanGameStateForClient(messageToSend.auctionState);
        }

        wss.clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN && client.roomId === roomId) {
                client.send(JSON.stringify(messageToSend));
            }
        });
    }

    function sendToClient(ws, message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            // If the message contains gameState, sanitize it before sending
            let messageToSend = { ...message }; // Shallow copy of the message object
            if (messageToSend.state) {
                messageToSend.state = getCleanGameStateForClient(messageToSend.state);
            } else if (messageToSend.auctionState) {
                messageToSend.auctionState = getCleanGameStateForClient(messageToSend.auctionState);
            }
            ws.send(JSON.stringify(messageToSend));
        }
    }

    function startAuctionTimer(roomId) {
        const room = gameRooms[roomId];
        if (!room) return;

        if (room.gameState.timer.interval) {
            clearInterval(room.gameState.timer.interval);
        }
        room.gameState.timer.endTime = Date.now() + (room.gameState.gameSettings.auctionRoundDuration * 1000);
        room.gameState.timer.active = true;

        room.gameState.timer.interval = setInterval(() => {
            const remainingTime = Math.max(0, Math.floor((room.gameState.timer.endTime - Date.now()) / 1000));
            if (remainingTime <= 0) {
                clearInterval(room.gameState.timer.interval);
                room.gameState.timer.active = false;
                room.gameState.timer.interval = null;
                console.log(`Room ${roomId}: Auction timer ran out. Finalizing item...`);
                finalizeCurrentAuction(roomId, true);
            }
            broadcastToRoom(roomId, { type: 'auction_state_update', state: room.gameState });
        }, 1000);
    }

    function resetAuctionTimer(roomId) {
        const room = gameRooms[roomId];
        if (!room) return;
        if (room.gameState.auctionState === 'bidding') {
            clearInterval(room.gameState.timer.interval);
            startAuctionTimer(roomId);
        }
    }

    function stopAuctionTimer(roomId) {
        const room = gameRooms[roomId];
        if (!room) return;
        if (room.gameState.timer.interval) {
            clearInterval(room.gameState.timer.interval);
            room.gameState.timer.interval = null;
        }
        room.gameState.timer.active = false;
        room.gameState.timer.endTime = 0;
    }

    function finalizeCurrentAuction(roomId, byTimer = false) {
        const room = gameRooms[roomId];
        if (!room) return;
        if (room.gameState.auctionState !== 'bidding' || !room.gameState.currentAuctionItem) {
            return;
        }
        stopAuctionTimer(roomId);

        const wonItem = room.gameState.currentAuctionItem;
        const finalBid = room.gameState.currentHighestBid;
        const winnerId = room.gameState.currentHighestBidder;
        const winnerName = room.gameState.players[winnerId]?.name;

        if (winnerId && room.gameState.players[winnerId]) {
            room.gameState.players[winnerId].wonItems.push({ ...wonItem, finalBid });
            const itemInList = room.gameState.items.find(item => item.id === wonItem.id);
            if (itemInList) itemInList.status = 'sold';

            broadcastToRoom(roomId, {
                type: 'item_finalized',
                item: wonItem,
                finalBid: finalBid,
                winnerId: winnerId,
                winnerName: winnerName,
                auctionState: room.gameState // Will be sanitized by broadcastToRoom
            });
            console.log(`Room ${roomId}: Item "${wonItem.name}" sold to ${winnerName || winnerId.substring(0,8)} for $${finalBid.toLocaleString()}`);
        } else {
            const itemInList = room.gameState.items.find(item => item.id === wonItem.id);
            if (itemInList) itemInList.status = 'pending';

            broadcastToRoom(roomId, {
                type: 'info',
                message: byTimer ? `Time's up! "${wonItem.name}" finalized with no winner (no bids). Item returned to pending.`
                                : `"${wonItem.name}" finalized with no winner (no bids). Item returned to pending.`
            });
            console.log(`Room ${roomId}: Item "${wonItem.name}" had no bids and was not sold.`);
        }

        room.gameState.currentAuctionItem = null;
        room.gameState.currentHighestBid = 0;
        room.gameState.currentHighestBidder = null;
        room.gameState.auctionState = 'idle';
        broadcastToRoom(roomId, { type: 'auction_state_update', state: room.gameState });
    }

    // --- LLM Integration Function ---
    const genAI = GEMINI_API_KEY ? new GoogleGenerativeAI(GEMINI_API_KEY) : null;
    const model = genAI ? genAI.getGenerativeModel({ model: GEMINI_MODEL_NAME }) : null;

    async function handleLlmQuery(query, role, roomId) {
        if (!model) {
            console.warn("Gemini model not initialized. API key might be missing.");
            return `(AI Helper for ${role}): AI is currently unavailable. Please check the server configuration (API key).`;
        }

        const room = gameRooms[roomId];
        const currentGameState = room ? room.gameState : null;

        let gameContext = `You are an AI assistant for an online auction game. The current room ID is ${roomId}.`;
        gameContext += `\nYour role: ${role}.`;

        if (currentGameState) {
            gameContext += `\nGame Settings: Player Starting Budget = $${currentGameState.gameSettings.playerStartingBudget.toLocaleString()}, Min Bid Increment = ${currentGameState.gameSettings.minBidIncrementPercentage}%, Auction Round Duration = ${currentGameState.gameSettings.auctionRoundDuration} seconds.`;
            gameContext += `\nAuction State: ${currentGameState.auctionState}.`;
            if (currentGameState.currentAuctionItem) {
                gameContext += `\nCurrently Auctioning: "${currentGameState.currentAuctionItem.name}" (Base Price: $${currentGameState.currentAuctionItem.basePrice.toLocaleString()}).`;
                gameContext += `\nCurrent Highest Bid: $${currentGameState.currentHighestBid.toLocaleString()}.`;
                if (currentGameState.currentHighestBidder) {
                    const bidderName = currentGameState.players[currentGameState.currentHighestBidder]?.name || currentGameState.currentHighestBidder.substring(0,8);
                    gameContext += `\nHighest Bidder: ${bidderName}.`;
                } else {
                    gameContext += `\nNo bids placed yet.`;
                }
            } else {
                gameContext += `\nNo item currently selected for auction.`;
            }
            const activePlayers = Object.values(currentGameState.players).filter(p => p.ws && p.ws.readyState === WebSocket.OPEN);
            if (activePlayers.length > 0) {
                 gameContext += `\nConnected Players: ${activePlayers.map(p => p.name).join(', ')}.`;
            }
        }

        const prompt = `
        ${gameContext}

        The user is asking: "${query}"

        Based on the game context, provide a helpful and concise response. If the question is about rules, explain the relevant rule. If it's about the current item, describe its status. If it's a general question not covered by specific game rules, provide a helpful general answer. If it asks about a specific player's budget, state that you do not have access to individual player budgets. Keep your response brief and to the point, acting as a supportive game assistant.
        `;

        try {
            const result = await model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            return text;
        } catch (error) {
            console.error("Error calling Gemini API:", error);
            return `(AI Helper for ${role}): I apologize, I'm having trouble connecting to my knowledge base right now. Please try again later. (Error: ${error.message})`;
        }
    }


    // --- WebSocket Connection Handling ---
    wss.on('connection', ws => {
        ws.id = uuidv4();
        ws.roomId = null;
        ws.playerId = null;
        ws.role = 'guest';
        console.log(`Client ${ws.id} connected`);

        sendToClient(ws, { type: 'client_id_assigned', id: ws.id });

        ws.on('message', async message => {
            const data = JSON.parse(message);
            console.log(`Received from ${ws.id} (Role: ${ws.role}, Room: ${ws.roomId}):`, data);

            switch (data.type) {
                case 'create_room':
                    if (ws.roomId) return sendToClient(ws, { type: 'error', message: 'You are already in a room. Leave first to create a new one.' });

                    const newRoomId = generateRoomId();
                    gameRooms[newRoomId] = {
                        gameState: createNewGameState(),
                        auctioneerWsId: ws.id,
                    };
                    ws.roomId = newRoomId;
                    ws.role = 'auctioneer';
                    ws.playerId = uuidv4();

                    const newAuctioneerPlayer = {
                        name: `Auctioneer ${ws.playerId.substring(0,8)}`,
                        budget: gameRooms[newRoomId].gameState.gameSettings.playerStartingBudget,
                        wonItems: [],
                        ws: ws
                    };
                    gameRooms[newRoomId].gameState.players[ws.playerId] = newAuctioneerPlayer;

                    sendToClient(ws, { type: 'room_created', roomId: newRoomId });
                    sendToClient(ws, { type: 'joined_room', roomId: newRoomId, role: 'auctioneer', playerId: ws.playerId, playerName: newAuctioneerPlayer.name, budget: newAuctioneerPlayer.budget });
                    broadcastToRoom(newRoomId, { type: 'info', message: `Auction Room "${newRoomId}" created by Auctioneer ${newAuctioneerPlayer.name}.` });
                    broadcastToRoom(newRoomId, { type: 'auction_state_update', state: gameRooms[newRoomId].gameState });
                    console.log(`Room ${newRoomId} created by ${ws.id}`);
                    return;

                case 'join_room':
                    if (ws.roomId) return sendToClient(ws, { type: 'error', message: 'You are already in a room.' });
                    const targetRoomId = data.roomId?.toUpperCase();
                    if (!targetRoomId || !gameRooms[targetRoomId]) {
                        return sendToClient(ws, { type: 'room_not_found', message: `Room "${targetRoomId}" not found.` });
                    }

                    ws.roomId = targetRoomId;
                    ws.role = 'player';
                    ws.playerId = uuidv4();

                    const newPlayer = {
                        name: data.playerName || `Player ${ws.playerId.substring(0,8)}`,
                        budget: gameRooms[targetRoomId].gameState.gameSettings.playerStartingBudget,
                        wonItems: [],
                        ws: ws
                    };
                    gameRooms[targetRoomId].gameState.players[ws.playerId] = newPlayer;

                    sendToClient(ws, { type: 'joined_room', roomId: targetRoomId, role: 'player', playerId: ws.playerId, playerName: newPlayer.name, budget: newPlayer.budget });
                    broadcastToRoom(targetRoomId, { type: 'info', message: `${newPlayer.name} joined the game.` });
                    broadcastToRoom(targetRoomId, { type: 'auction_state_update', state: gameRooms[targetRoomId].gameState });
                    console.log(`Client ${ws.id} joined room ${targetRoomId} as player ${ws.playerId}`);
                    return;

                case 'reconnect_session':
                    if (data.roomId && gameRooms[data.roomId]) {
                        const room = gameRooms[data.roomId];
                        if (data.role === 'auctioneer' && room.auctioneerWsId === data.clientId) {
                            ws.roomId = data.roomId;
                            ws.role = 'auctioneer';
                            ws.playerId = data.clientId;
                            if (room.gameState.players[ws.playerId]) {
                                room.gameState.players[ws.playerId].ws = ws;
                                room.auctioneerWsId = ws.id;
                                sendToClient(ws, {
                                    type: 'reconnected_session',
                                    roomId: ws.roomId,
                                    role: 'auctioneer',
                                    playerId: ws.playerId,
                                    playerName: room.gameState.players[ws.playerId].name,
                                    budget: room.gameState.players[ws.playerId].budget
                                });
                                broadcastToRoom(ws.roomId, { type: 'info', message: `Auctioneer ${room.gameState.players[ws.playerId].name} reconnected.` });
                                broadcastToRoom(ws.roomId, { type: 'auction_state_update', state: room.gameState });
                                console.log(`Client ${ws.id} reconnected to room ${ws.roomId} as AUCTIONEER.`);
                            } else {
                                console.log(`Reconnect failed: Auctioneer player data missing for ${data.clientId}.`);
                                sendToClient(ws, { type: 'error', message: 'Reconnect failed: Auctioneer session data corrupted. Please create a new room.' });
                            }
                        }
                        else if (data.role === 'player' && room.gameState.players[data.clientId]) {
                            ws.roomId = data.roomId;
                            ws.role = 'player';
                            ws.playerId = data.clientId;
                            room.gameState.players[ws.playerId].ws = ws;
                            if (data.playerName) room.gameState.players[ws.playerId].name = data.playerName;
                            sendToClient(ws, {
                                type: 'reconnected_session',
                                roomId: ws.roomId,
                                role: 'player',
                                playerId: ws.playerId,
                                playerName: room.gameState.players[ws.playerId].name,
                                budget: room.gameState.players[ws.playerId].budget
                            });
                            broadcastToRoom(ws.roomId, { type: 'info', message: `Player ${room.gameState.players[ws.playerId].name} reconnected.` });
                            broadcastToRoom(ws.roomId, { type: 'auction_state_update', state: room.gameState });
                            console.log(`Client ${ws.id} reconnected to room ${ws.roomId} as PLAYER ${ws.playerId}.`);
                        } else {
                             sendToClient(ws, { type: 'error', message: 'Reconnect failed. Session data mismatch or invalid.' });
                             console.log(`Client ${ws.id} failed to reconnect to room ${data.roomId}.`);
                        }
                    } else {
                        sendToClient(ws, { type: 'error', message: 'Reconnect failed. Room not found or invalid session.' });
                        console.log(`Client ${ws.id} failed to reconnect to room ${data.roomId}.`);
                    }
                    return;
            }

            if (!ws.roomId || !gameRooms[ws.roomId]) {
                return sendToClient(ws, { type: 'error', message: 'You must be in a room to perform this action.' });
            }
            const currentRoom = gameRooms[ws.roomId];
            const currentGameState = currentRoom.gameState;

            switch (data.type) {
                case 'set_player_name':
                    if (ws.playerId !== data.playerId || !currentGameState.players[data.playerId]) return sendToClient(ws, { type: 'error', message: 'Invalid player for this action.' });
                    if (!data.name || data.name.trim() === '') return sendToClient(ws, { type: 'error', message: 'Player name cannot be empty.' });
                    currentGameState.players[data.playerId].name = data.name.trim().substring(0, 20);
                    broadcastToRoom(ws.roomId, { type: 'auction_state_update', state: currentGameState });
                    sendToClient(ws, { type: 'info', message: `Your display name is now "${currentGameState.players[data.playerId].name}".` });
                    break;

                case 'update_settings':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can update game settings.' });

                    const { playerStartingBudget, minBidIncrementPercentage, auctionRoundDuration } = data.settings;

                    if (isNaN(playerStartingBudget) || playerStartingBudget < 100 ||
                        isNaN(minBidIncrementPercentage) || minBidIncrementPercentage < 1 || minBidIncrementPercentage > 100 ||
                        isNaN(auctionRoundDuration) || auctionRoundDuration < 5 || auctionRoundDuration > 120) {
                        return sendToClient(ws, { type: 'error', message: 'Invalid setting values. Budget (min 100), Increment (1-100%), Duration (5-120s).' });
                    }

                    currentGameState.gameSettings.playerStartingBudget = playerStartingBudget;
                    currentGameState.gameSettings.minBidIncrementPercentage = minBidIncrementPercentage;
                    currentGameState.gameSettings.auctionRoundDuration = auctionRoundDuration;

                    broadcastToRoom(ws.roomId, { type: 'settings_updated', settings: currentGameState.gameSettings });
                    console.log(`Room ${ws.roomId}: Game settings updated:`, currentGameState.gameSettings);
                    break;

                case 'add_item':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can add items.' });
                    if (!data.name || isNaN(data.basePrice) || data.basePrice < 0) return sendToClient(ws, { type: 'error', message: 'Invalid item details.' });

                    const newItem = {
                        id: uuidv4(),
                        name: data.name,
                        basePrice: parseFloat(data.basePrice),
                        status: 'pending'
                    };
                    currentGameState.items.push(newItem);
                    broadcastToRoom(ws.roomId, { type: 'item_added', item: newItem, items: currentGameState.items });
                    break;

                case 'add_batch_items':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can add items in batch.' });
                    if (!data.items || !Array.isArray(data.items) || data.items.length === 0) return sendToClient(ws, { type: 'error', message: 'No valid items provided for batch inclusion.' });

                    let addedCount = 0;
                    data.items.forEach(itemData => {
                        const name = itemData.name;
                        const basePrice = parseFloat(itemData.basePrice);
                        if (name && !isNaN(basePrice) && basePrice >= 0) {
                            const newItem = {
                                id: uuidv4(),
                                name: name,
                                basePrice: basePrice,
                                status: 'pending'
                            };
                            currentGameState.items.push(newItem);
                            addedCount++;
                        }
                    });
                    broadcastToRoom(ws.roomId, { type: 'batch_items_added', count: addedCount, items: currentGameState.items });
                    break;

                case 'select_item_for_auction':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can select items.' });
                    if (currentGameState.auctionState !== 'idle') {
                        return sendToClient(ws, { type: 'error', message: 'An auction is already in progress. Finalize or clear it first.' });
                    }

                    const itemToAuction = currentGameState.items.find(item => item.id === data.itemId && item.status === 'pending');
                    if (itemToAuction) {
                        currentGameState.currentAuctionItem = itemToAuction;
                        currentGameState.currentHighestBid = itemToAuction.basePrice;
                        currentGameState.currentHighestBidder = null;
                        currentGameState.auctionState = 'item_selected';
                        itemToAuction.status = 'auctioning';
                        broadcastToRoom(ws.roomId, { type: 'auction_state_update', state: currentGameState });
                        broadcastToRoom(ws.roomId, { type: 'info', message: `Auctioneer selected "${itemToAuction.name}" for auction. Base price: $${itemToAuction.basePrice.toLocaleString()}` });
                    } else {
                        sendToClient(ws, { type: 'error', message: 'Item not found or already auctioned/selected.' });
                    }
                    break;

                case 'start_bidding':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can start bidding.' });
                    if (currentGameState.auctionState !== 'item_selected' || !currentGameState.currentAuctionItem) {
                        return sendToClient(ws, { type: 'error', message: 'No item selected or bidding already started.' });
                    }
                    currentGameState.auctionState = 'bidding';
                    startAuctionTimer(ws.roomId);
                    broadcastToRoom(ws.roomId, { type: 'auction_state_update', state: currentGameState });
                    broadcastToRoom(ws.roomId, { type: 'info', message: `Bidding started for "${currentGameState.currentAuctionItem.name}"!` });
                    break;

                case 'finalize_item':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can finalize items.' });
                    finalizeCurrentAuction(ws.roomId, false);
                    break;

                case 'clear_auction':
                    if (ws.id !== currentRoom.auctioneerWsId) return sendToClient(ws, { type: 'error', message: 'Only the auctioneer can clear the auction.' });

                    stopAuctionTimer(ws.roomId);

                    if (currentGameState.currentAuctionItem) {
                        const itemInList = currentGameState.items.find(item => item.id === currentGameState.currentAuctionItem.id);
                        if (itemInList && itemInList.status === 'auctioning') {
                            itemInList.status = 'pending';
                        }
                        if (currentGameState.currentHighestBidder && currentGameState.players[currentGameState.currentHighestBidder] && currentGameState.auctionState === 'bidding') {
                             const player = currentGameState.players[currentGameState.currentHighestBidder];
                            if (player.ws && player.ws.readyState === WebSocket.OPEN && player.budget + currentGameState.currentHighestBid <= currentGameState.gameSettings.playerStartingBudget) {
                                player.budget += currentGameState.currentHighestBid;
                                sendToClient(player.ws, {
                                    type: 'player_bid_update',
                                    playerBudget: player.budget,
                                    message: `Auction for "${currentGameState.currentAuctionItem.name}" cleared. Your bid refunded.`,
                                    success: true
                                });
                            }
                        }
                    }
                    currentGameState.currentAuctionItem = null;
                    currentGameState.currentHighestBid = 0;
                    currentGameState.currentHighestBidder = null;
                    currentGameState.auctionState = 'idle';
                    broadcastToRoom(ws.roomId, { type: 'auction_cleared', auctionState: currentGameState }); // Will be sanitized by broadcastToRoom
                    break;

                case 'place_bid':
                    if (ws.playerId !== data.playerId || !currentGameState.players[data.playerId]) return sendToClient(ws, { type: 'error', message: 'Invalid player or action.' });
                    if (currentGameState.auctionState !== 'bidding' || !currentGameState.currentAuctionItem) {
                        return sendToClient(ws, { type: 'error', message: 'Bidding is not active for an item.' });
                    }

                    const player = currentGameState.players[data.playerId];
                    const bid = parseFloat(data.bidAmount);
                    const minAllowedBid = Math.ceil(currentGameState.currentHighestBid * (1 + currentGameState.gameSettings.minBidIncrementPercentage / 100));

                    if (isNaN(bid) || bid < minAllowedBid) {
                        return sendToClient(ws, { type: 'error', message: `Bid must be at least $${minAllowedBid.toLocaleString()}.` });
                    }
                    if (bid > player.budget) {
                        return sendToClient(ws, { type: 'error', message: `Bid of $${bid.toLocaleString()} exceeds your budget of $${player.budget.toLocaleString()}.` });
                    }

                    if (currentGameState.currentHighestBidder && currentGameState.players[currentGameState.currentHighestBidder] && currentGameState.currentHighestBidder !== ws.playerId) {
                        const prevHighestBidder = currentGameState.players[currentGameState.currentHighestBidder];
                        if (prevHighestBidder.ws && prevHighestBidder.ws.readyState === WebSocket.OPEN) {
                            prevHighestBidder.budget += currentGameState.currentHighestBid;
                            sendToClient(prevHighestBidder.ws, {
                                type: 'player_bid_update',
                                playerBudget: prevHighestBidder.budget,
                                message: `Your bid of $${currentGameState.currentHighestBid.toLocaleString()} for "${currentGameState.currentAuctionItem.name}" was outbid. Budget refunded.`,
                                success: true
                            });
                        }
                    }

                    player.budget -= bid;
                    currentGameState.currentHighestBid = bid;
                    currentGameState.currentHighestBidder = data.playerId;

                    resetAuctionTimer(ws.roomId);

                    broadcastToRoom(ws.roomId, {
                        type: 'player_bid_update',
                        auctionState: currentGameState, // Will be sanitized by broadcastToRoom
                        playerId: ws.playerId,
                        playerBudget: player.budget,
                        message: `${player.name} bid $${bid.toLocaleString()} for "${currentGameState.currentAuctionItem.name}".`,
                        success: true
                    });
                    break;

                case 'llm_query':
                    const llmResponse = await handleLlmQuery(data.query, data.role, data.roomId);
                    sendToClient(ws, {
                        type: 'llm_response',
                        response: llmResponse,
                        clientId: data.clientId
                    });
                    break;

                default:
                    sendToClient(ws, { type: 'error', message: 'Unknown message type.' });
                    break;
            }
        });

        ws.on('close', () => {
            console.log(`Client ${ws.id} disconnected (Room: ${ws.roomId}, Role: ${ws.role})`);

            if (!ws.roomId || !gameRooms[ws.roomId]) {
                return;
            }

            const room = gameRooms[ws.roomId];
            const currentGameState = room.gameState;

            if (ws.id === room.auctioneerWsId) {
                room.auctioneerWsId = null;
                broadcastToRoom(ws.roomId, { type: 'info', message: 'Auctioneer disconnected. Auction halted.' });

                if (currentGameState.currentAuctionItem && currentGameState.currentAuctionItem.status === 'auctioning') {
                    const itemInList = currentGameState.items.find(item => item.id === currentGameState.currentAuctionItem.id);
                    if (itemInList) itemInList.status = 'pending';
                }
                if (currentGameState.currentHighestBidder && currentGameState.players[currentGameState.currentHighestBidder] && currentGameState.auctionState === 'bidding') {
                     const player = currentGameState.players[currentGameState.currentHighestBidder];
                    if (player.ws && player.ws.readyState === WebSocket.OPEN && player.budget + currentGameState.currentHighestBid <= currentGameState.gameSettings.playerStartingBudget) {
                        player.budget += currentGameState.currentHighestBid;
                        sendToClient(player.ws, {
                            type: 'player_bid_update',
                            playerBudget: player.budget,
                            message: `Auctioneer disconnected. Your bid for "${currentGameState.currentAuctionItem.name}" refunded.`,
                            success: true
                        });
                    }
                }
                currentGameState.currentAuctionItem = null;
                currentGameState.currentHighestBid = 0;
                currentGameState.currentHighestBidder = null;
                currentGameState.auctionState = 'idle';
                stopAuctionTimer(ws.roomId);
                broadcastToRoom(ws.roomId, { type: 'auction_cleared', auctionState: currentGameState }); // Will be sanitized by broadcastToRoom

                const remainingPlayersInRoom = Object.values(currentGameState.players).filter(p => p.ws && p.ws.readyState === WebSocket.OPEN);
                if (remainingPlayersInRoom.length === 0) {
                    stopAuctionTimer(ws.roomId);
                    delete gameRooms[ws.roomId];
                    console.log(`Room ${ws.roomId} deleted as all clients disconnected.`);
                }
            } else if (ws.role === 'player' && ws.playerId && currentGameState.players[ws.playerId]) {
                const playerName = currentGameState.players[ws.playerId].name;
                if (currentGameState.currentHighestBidder === ws.playerId) {
                    currentGameState.currentHighestBidder = null;
                    if (currentGameState.currentAuctionItem) {
                        currentGameState.currentHighestBid = currentGameState.currentAuctionItem.basePrice;
                    } else {
                        currentGameState.currentHighestBid = 0;
                    }
                    broadcastToRoom(ws.roomId, { type: 'info', message: `${playerName} disconnected. Highest bid retracted. Current bid reset to $${currentGameState.currentHighestBid.toLocaleString()}.` });
                    resetAuctionTimer(ws.roomId);
                    broadcastToRoom(ws.roomId, { type: 'auction_state_update', state: currentGameState }); // Will be sanitized by broadcastToRoom
                }
                // Mark player's websocket as null/invalidated, don't delete player object immediately in case of reconnect
                // This ensures the player data (name, budget, wonItems) persists for a potential reconnection
                currentGameState.players[ws.playerId].ws = null;

                broadcastToRoom(ws.roomId, { type: 'info', message: `${playerName} left the game.` });

                const activeClientsInRoom = Array.from(wss.clients).filter(client => client.roomId === ws.roomId && client.readyState === WebSocket.OPEN);
                // Also check if the auctioneer is still connected (auctioneerWsId is not null AND their WS is active)
                const auctioneerActive = room.auctioneerWsId && Array.from(wss.clients).find(c => c.id === room.auctioneerWsId && c.readyState === WebSocket.OPEN);

                if (activeClientsInRoom.length === 0 && !auctioneerActive) {
                    stopAuctionTimer(ws.roomId);
                    delete gameRooms[ws.roomId];
                    console.log(`Room ${ws.roomId} deleted as all clients disconnected.`);
                }
            }
        });

        ws.on('error', error => {
            console.error(`WebSocket Error for client ${ws.id} (Room: ${ws.roomId}, Role: ${ws.role}):`, error);
        });
    });

    server.listen(PORT, () => {
        console.log(`Server listening on http://localhost:${PORT}`);
        console.log(`WebSocket server running on ws://localhost:${PORT}`);
        if (!GEMINI_API_KEY) {
             console.warn("WARNING: GEMINI_API_KEY is not set. AI assistant will not function.");
        }
    });
})();

-----------------------------------------------------------

:root {
    --primary-bg: #1c1c1c; /* Dark charcoal */
    --secondary-bg: #2a2a2a; /* Slightly lighter charcoal */
    --tertiary-bg: #333; /* Even lighter for nested elements/cards */
    --accent-gold: #c7a76c; /* Rich gold */
    --light-text: #e0e0e0;
    --dark-text: #333;
    --border-color: #555;
    --success-color: #4CAF50;
    --error-color: #f44336;
    --info-color: #2196F3;

    --llm-bg: #3c3c3c;
    --llm-bot-msg-bg: #4a4a4a;
    --llm-user-msg-bg: #007bff;
}

body {
    font-family: 'Merriweather', serif;
    margin: 0;
    padding: 0;
    background-color: var(--primary-bg);
    color: var(--light-text);
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
}

.header {
    width: 100%;
    background-color: var(--secondary-bg);
    padding: 1.2rem 0; /* Adjusted padding */
    text-align: center;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    margin-bottom: 20px;
}

h1 {
    font-family: 'Playfair Display', serif;
    color: var(--accent-gold);
    margin: 0;
    font-size: clamp(2.5rem, 6vw, 3.5rem); /* Responsive font size */
    letter-spacing: 2px;
    text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
}

h2, h3 {
    font-family: 'Playfair Display', serif;
    color: var(--accent-gold);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.6rem; /* Adjusted padding */
    margin-top: 1.5rem; /* Adjusted margin */
    margin-bottom: 1rem; /* Adjusted margin */
}

/* New wrapper to allow content to flex-grow */
.game-wrapper {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 95%;
    max-width: 1400px;
    padding-bottom: 20px; /* Adjusted padding */
}

/* Main game panels container */
.game-container {
    display: flex;
    flex-wrap: wrap; /* Allows panels to wrap on smaller screens */
    justify-content: center;
    gap: 1.5rem; /* Consistent gap between panels */
    width: 100%;
}

/* Card styling for internal sections */
.card {
    background-color: var(--tertiary-bg); /* Slightly lighter background for cards */
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1); /* Subtle inner shadow */
}


/* Room Selection Area (Initial Screen) */
.room-selection-area {
    background-color: var(--secondary-bg);
    padding: 2.5rem; /* More generous padding */
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    text-align: center;
    width: 100%;
    max-width: 600px; /* Increased max-width for better look */
    margin: 3rem auto; /* Centered with top/bottom margin */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem; /* Space between welcome and actions section */
}

.welcome-section {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px dashed var(--border-color);
}
.welcome-section h2 {
    font-size: clamp(2rem, 5vw, 2.8rem); /* Responsive font size for welcome title */
    margin-bottom: 0.5rem;
    border-bottom: none; /* Remove border from H2 inside welcome */
}
.welcome-section p {
    font-size: 1.1em;
    color: #ccc;
    margin: 0;
}

.room-actions-section {
    width: 100%; /* Ensure it takes full width of its parent */
    display: flex;
    flex-direction: column; /* Stack actions vertically */
    gap: 1rem;
    align-items: center;
}

.room-selection-area .input-group {
    display: flex;
    flex-direction: column; /* Stack input and button by default for responsiveness */
    gap: 0.5rem;
    margin-bottom: 0.5rem; /* Adjusted margin */
    width: 100%;
}
.room-selection-area .input-group input {
    width: auto; /* Let flex handle width */
    flex-grow: 1;
}
.room-selection-area .input-group button {
    width: 100%; /* Buttons fill available width */
    margin-right: 0; /* Remove right margin */
}
.room-selection-area .or-divider {
    margin: 0.5rem 0; /* Adjusted margin */
    font-style: italic;
    color: #888;
    font-size: 0.9em;
}
.room-selection-area .action-btn.create-room-btn {
    width: 100%;
    margin-top: 0;
    padding: 1.2rem; /* Larger padding for prominence */
    font-size: 1.1em;
}

/* General Layout for Aside and Main */
aside, main.main-auction-area {
    background-color: var(--secondary-bg);
    padding: 1.5rem; /* Consistent padding */
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    flex: 1; /* Allow flexing */
    min-width: 320px; /* Smaller min-width for mobile */
    max-width: 480px; /* Max-width for panels */
    display: flex;
    flex-direction: column;
    gap: 1.2rem; /* Consistent gap between sections within panels */
}

main.main-auction-area {
    flex: 2; /* Main area takes more space */
    min-width: 320px;
    max-width: 700px; /* Larger max-width for central content */
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
    padding: 2rem; /* More padding for central area */
}


.message-area {
    background-color: var(--info-color);
    color: white;
    padding: 0.75rem 1.25rem; /* Adjusted padding */
    border-radius: 8px;
    margin-bottom: 1.25rem; /* Adjusted margin */
    text-align: center;
    width: 80%;
    max-width: 600px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: none; /* Hidden by default */
    font-weight: bold;
    opacity: 0;
    transform: translateY(-20px);
    transition: opacity 0.3s ease-out, transform 0.3s ease-out, background-color 0.3s ease;
    position: fixed;
    top: 1.25rem; /* Adjusted top position */
    z-index: 1000;
}
.message-area.show {
    opacity: 1;
    transform: translateY(0);
}
.message-area.success { background-color: var(--success-color); }
.message-area.error { background-color: var(--error-color); }


/* Buttons and Inputs */
button, input[type="text"], input[type="number"], textarea, input[type="file"] {
    padding: 0.75rem 1rem; /* Adjusted padding */
    border-radius: 6px;
    border: 1px solid var(--border-color);
    font-size: 1em;
    font-family: 'Merriweather', serif;
}

input[type="text"], input[type="number"], textarea {
    background-color: var(--secondary-bg); /* Use secondary background for inputs */
    color: var(--light-text);
    width: calc(100% - 22px); /* Account for padding+border */
    margin-bottom: 0.5rem; /* Adjusted margin */
    transition: border-color 0.3s ease;
}
input[type="text"]:focus, input[type="number"]:focus, textarea:focus {
    border-color: var(--accent-gold);
    outline: none;
}

button {
    background-color: var(--accent-gold);
    color: var(--primary-bg);
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.1s ease;
    font-weight: bold;
    border: none;
    margin-right: 0.5rem; /* Adjusted margin */
}
button:hover:not(:disabled) {
    background-color: #d1b87c;
    transform: translateY(-2px);
}
button:active:not(:disabled) {
    transform: translateY(0);
}
button:disabled {
    background-color: #666;
    cursor: not-allowed;
    color: #bbb;
}

.action-btn {
    background-color: var(--success-color);
    color: white;
}
.action-btn:hover:not(:disabled) {
    background-color: #45a049;
}
.finalize-btn {
    background-color: var(--error-color);
}
.finalize-btn:hover:not(:disabled) {
    background-color: #da190b;
}
.clear-btn {
    background-color: #ff9800;
}
.clear-btn:hover:not(:disabled) {
    background-color: #e68a00;
}
.bid-btn, #setPlayerNameBtn {
    background-color: var(--info-color);
    color: white;
}
.bid-btn:hover:not(:disabled), #setPlayerNameBtn:hover:not(:disabled) {
    background-color: #0056b3;
}


/* Player Specific Styles */
.player-info {
    /* Uses .card style */
    border: 1px dashed var(--accent-gold); /* Dashed border for player info */
}
.player-info p {
    margin: 0.3rem 0; /* Adjusted margin */
}
.player-id, .room-id {
    color: var(--accent-gold);
    font-weight: bold;
}
.current-room-display {
    text-align: center;
    font-size: 1.1em;
    font-style: italic;
    color: #bbb;
    margin-bottom: 1rem;
}
.budget-display {
    font-size: 1.3em;
    font-weight: bold;
    color: var(--success-color);
    margin-top: 0.75rem !important;
}
#playerNameInput {
    width: calc(100% - 22px);
    margin-bottom: 0.5rem;
}
#setPlayerNameBtn {
    width: 100%;
    margin-top: 0.5rem;
    margin-right: 0;
}


/* Auction Display */
.auction-display {
    /* Uses .card style */
    transition: all 0.3s ease;
}
.auction-display .item-name {
    font-family: 'Playfair Display', serif;
    font-size: 1.3em; /* Slightly smaller for better fit */
    color: var(--accent-gold);
    margin-bottom: 0.75rem;
}
.auction-display .current-bid {
    font-size: 1.8em; /* Slightly smaller */
    font-weight: bold;
    color: var(--success-color);
    transition: color 0.3s ease, transform 0.3s ease;
}
.auction-display .current-bid.new-bid-effect {
    color: var(--accent-gold);
    transform: scale(1.1);
}
.auction-display .highest-bidder {
    font-size: 1em; /* Adjusted font size */
    color: var(--light-text);
}

.bid-input-area {
    margin-top: 1rem;
    border-top: 1px dashed var(--border-color);
    padding-top: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}
.bid-input-area input {
    margin-bottom: 0;
}
.bid-input-area button {
    width: 100%;
    margin-right: 0;
}

/* Item List Styles */
.item-list {
    list-style-type: none;
    padding: 0;
    max-height: 250px; /* Adjusted max height */
    overflow-y: auto;
    border-top: none; /* Removed redundant border-top as .card handles border */
    padding-top: 0; /* Removed redundant padding-top */
    margin-top: 0;
}
.item-list li {
    background-color: var(--secondary-bg); /* Use secondary bg for list items */
    margin-bottom: 0.5rem;
    padding: 0.75rem;
    border-radius: 6px;
    display: flex;
    flex-wrap: wrap; /* Allow content inside list item to wrap */
    justify-content: space-between;
    align-items: center;
    border-left: 5px solid transparent;
    transition: all 0.3s ease;
    font-size: 0.9em;
}
.item-list li.placeholder-item {
    text-align: center;
    color: #888;
    font-style: italic;
    background-color: transparent;
    padding: 1rem;
}
.item-list li.current-auction-item {
    background-color: #4a4a4a;
    border-left-color: var(--accent-gold);
    font-weight: bold;
    box-shadow: 0 0 10px rgba(199, 167, 108, 0.3);
}
.item-list li.sold-item {
    border-left-color: var(--success-color);
    opacity: 0.7;
    text-decoration: line-through;
}
.item-list li button {
    margin-left: 0.5rem;
    padding: 0.5rem 0.75rem;
    font-size: 0.8em;
    background-color: var(--info-color);
    color: white;
}
.item-list li button:hover:not(:disabled) {
    background-color: #0056b3;
}
.item-list .item-details, .item-list .item-status {
    flex: 1 1 auto; /* Allow these spans to take space and wrap */
    min-width: 100px; /* Ensure they have a minimum width */
}
.item-list li button {
    flex-shrink: 0; /* Prevent button from shrinking */
    margin-top: 0.5rem; /* Add margin for stacking on small screens */
    margin-left: 0;
    width: 100%; /* Default to full width for better touch */
}
@media (min-width: 600px) { /* For wider screens, make button inline */
    .item-list li button {
        width: auto;
        margin-left: 0.5rem;
        margin-top: 0;
    }
}


/* Auctioneer specific styles */
.auctioneer-controls {
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
}
.game-settings, .item-management {
    /* Uses .card style */
    padding-bottom: 1rem; /* Consistent padding */
}
.game-settings label {
    display: block;
    margin-bottom: 0.3rem;
    font-size: 0.95em;
    color: var(--light-text);
}
.game-settings input {
    margin-bottom: 0.75rem;
}
.game-settings button {
    width: 100%;
    margin-top: 0.5rem;
    margin-right: 0;
}
.auction-management {
    /* Uses .card style */
    margin-bottom: 0; /* No external margin, .auctioneer-controls gap handles it */
}
.auction-management p {
    margin: 0.3rem 0;
}
#batchItemsInput {
    resize: vertical;
    width: calc(100% - 22px);
    margin-bottom: 0.5rem;
}
#batchCsvFileInput {
    width: calc(100% - 22px);
    padding: 0.5rem 0.75rem;
    margin-bottom: 0.5rem;
    background-color: var(--secondary-bg);
    color: var(--light-text);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
}
#batchCsvFileInput::file-selector-button {
    background-color: var(--info-color);
    color: white;
    border: none;
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    margin-right: 0.5rem;
    cursor: pointer;
    transition: background-color 0.3s ease;
}
#batchCsvFileInput::file-selector-button:hover {
    background-color: #0056b3;
}


/* Central Auction Area */
.central-auction-item {
    /* Uses .card style */
    width: 100%;
    height: 300px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    border: 2px dashed var(--accent-gold);
    padding: 1.5rem; /* Adjusted padding */
    margin-bottom: 1.2rem; /* Adjusted margin */
}
.central-auction-item .status-message {
    font-size: clamp(1.2rem, 3vw, 1.8rem); /* Responsive font size */
    color: #ccc;
    font-style: italic;
    margin-top: 1rem;
}
.central-auction-item h3 {
    font-size: clamp(1.8rem, 4vw, 2.5rem); /* Responsive font size */
    color: var(--accent-gold);
    margin-bottom: 0.75rem;
    border-bottom: none;
}
.central-auction-item p {
    font-size: 1.1em;
    margin: 0.3rem 0;
}
.central-auction-item .central-bid {
    font-size: clamp(2.5rem, 6vw, 3.5rem); /* Responsive font size */
    font-weight: bold;
    color: var(--success-color);
    transition: color 0.3s ease, transform 0.3s ease;
    text-shadow: 0 0 10px rgba(0,255,0,0.5);
}
.central-auction-item .central-bid.new-bid-effect {
    color: var(--accent-gold);
    transform: scale(1.15);
}
.central-auction-item .central-highest-bidder {
    font-size: clamp(1.1rem, 2vw, 1.5rem); /* Responsive font size */
    color: var(--light-text);
}


/* Auction Timer Display */
.auction-timer-display {
    background-color: var(--accent-gold);
    color: var(--primary-bg);
    font-family: 'Playfair Display', serif;
    font-size: clamp(1.5rem, 4vw, 2em); /* Responsive font size */
    font-weight: bold;
    padding: 1rem 1.5rem;
    border-radius: 10px;
    margin-bottom: 1.5rem;
    text-align: center;
    box-shadow: 0 0 15px rgba(199, 167, 108, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
}
#timer-countdown {
    min-width: 60px;
}
.auction-timer-display.time-low {
    background-color: var(--error-color);
    color: white;
    animation: pulseRed 1s infinite alternate;
}

/* Hammer Effect */
.auction-hammer-effect {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background-color: var(--accent-gold);
    color: var(--primary-bg);
    padding: 1.25rem 2.5rem;
    border-radius: 15px;
    font-family: 'Playfair Display', serif;
    font-size: clamp(2.5rem, 8vw, 4em); /* Responsive font size */
    font-weight: bold;
    opacity: 0;
    transition: all 0.5s ease-out;
    z-index: 100;
    box-shadow: 0 0 20px rgba(199, 167, 108, 0.7);
    white-space: nowrap;
}

.auction-hammer-effect.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
}

/* LLM Assistant Section */
.llm-assistant-section {
    /* Uses .card style */
    padding-bottom: 1rem;
}
.llm-assistant-section h3 {
    color: var(--info-color);
    border-bottom-color: #666;
    margin-top: 0;
    margin-bottom: 0.75rem;
}
.llm-chat-window {
    display: flex;
    flex-direction: column;
    height: 300px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    overflow: hidden;
}
.llm-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 0.75rem;
    background-color: var(--primary-bg);
}
.llm-message {
    margin: 0.3rem 0;
    padding: 0.5rem 0.75rem;
    border-radius: 15px;
    max-width: 80%;
    word-wrap: break-word;
    font-size: 0.9em;
}
.llm-message.bot {
    background-color: var(--llm-bot-msg-bg);
    align-self: flex-start;
    color: var(--light-text);
}
.llm-message.user {
    background-color: var(--llm-user-msg-bg);
    align-self: flex-end;
    color: white;
    margin-left: auto;
}
.llm-input-area {
    display: flex;
    border-top: 1px solid var(--border-color);
    padding: 0.75rem;
    background-color: var(--secondary-bg);
}
.llm-input-area input {
    flex-grow: 1;
    margin-bottom: 0;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    padding: 0.6rem 0.8rem;
}
.llm-input-area button {
    margin-left: 0.5rem;
    background-color: var(--info-color);
    color: white;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    padding: 0.6rem 1rem;
    margin-right: 0;
}
.llm-input-area button:hover:not(:disabled) {
    background-color: #1a7fb3;
}


/* Animations */
@keyframes pulseRed {
    from { box-shadow: 0 0 15px rgba(244, 67, 54, 0.5); }
    to { box-shadow: 0 0 25px rgba(244, 67, 54, 0.9); }
}

/* Scrollbar Styling */
.item-list::-webkit-scrollbar, .llm-messages::-webkit-scrollbar {
    width: 8px;
}
.item-list::-webkit-scrollbar-track, .llm-messages::-webkit-scrollbar-track {
    background: #3c3c3c;
    border-radius: 10px;
}
.item-list::-webkit-scrollbar-thumb, .llm-messages::-webkit-scrollbar-thumb {
    background: var(--accent-gold);
    border-radius: 10px;
}
.item-list::-webkit-scrollbar-thumb:hover, .llm-messages::-webkit-scrollbar-thumb:hover {
    background: #d1b87c;
}

/* Responsive adjustments */
@media (min-width: 768px) {
    /* Adjust input-group for room selection on wider screens */
    .room-selection-area .input-group {
        flex-direction: row; /* Input and button side-by-side */
        width: 80%; /* Don't stretch too wide */
    }
    .room-selection-area .input-group button {
        width: auto; /* Shrink button */
    }
    .room-selection-area .action-btn.create-room-btn {
        width: 80%;
    }
}

@media (max-width: 1200px) {
    .game-container {
        flex-direction: column; /* Stack panels vertically */
        align-items: center;
        gap: 1.5rem; /* Consistent gap when stacked */
    }
    aside, main.main-auction-area {
        max-width: 90%; /* Take more width when stacked */
        min-width: unset;
        width: 100%; /* Fill available space */
    }
}

@media (max-width: 768px) {
    h1 {
        font-size: 2rem; /* Smaller header on very small screens */
    }
    aside, main.main-auction-area {
        padding: 1rem; /* Less padding on small screens */
        gap: 0.8rem;
    }
    .central-auction-item {
        height: 250px; /* Slightly smaller central display */
        padding: 1rem;
    }
    .welcome-section h2 {
        font-size: 1.8rem;
    }
    .welcome-section p {
        font-size: 0.95em;
    }
    .auction-timer-display {
        font-size: 1.3em;
        padding: 0.75rem 1rem;
    }
    .auction-hammer-effect {
        font-size: 2rem;
        padding: 1rem 2rem;
    }
    .message-area {
        font-size: 0.9em;
        width: 90%;
        left: 5%; /* Centered horizontally */
        transform: translateX(0); /* Reset transform */
    }
    .message-area.show {
        transform: translateY(0); /* Just translateY */
    }
}

--------------------------------------------------

I've provided you with all the codes of my website. What I want you to fix is that... make the website more interactive so that who bought what could be seen by everyone. And the whole game will be... smooth and flawless. The players who are playing the game could enjoy and compete with each other and enjoy the game to the fullest. And another bug that I'm seeing is... that when a buyer or when a player or a participant is trying to bid, trying to place a bid, then the custom bid is not being taken or maybe its state management is not right. Maybe that's why when a user or a player goes to enter a custom bid, it re-updates to its previous bid. I mean, the default bid. Suppose a bid was... Yeah, that's it. I hope you understand what I'm trying to say. I might not be clear in my words, but please find that issue and fix it. As the timer updates, the custom bid that a user can input is also updating to its previous thing, so the user has to be very fast while typing the custom bid. Why would it happen like that? This is surely a bug. Please fix it. And another... The main big change that'll happen is what I've told you at first about making the game more interactive and enjoyable so that everyone can compete with each other and can see what they are buying and what the value of those buys are so they can compete with each other better. I hope you understand it. Add anything that will be best for the game into it, and... All right. All the best.