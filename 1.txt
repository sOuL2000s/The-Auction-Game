import os
import json
import random
import re # Import for regular expressions
import csv
import io
import copy # Import for deep copying game state

from flask import Flask, request, jsonify, render_template_string

# --- Configuration ---
app = Flask(__name__)

# --- Game State ---
# Define a function to get the initial game state, allowing for easy reset
def get_initial_game_state():
    return {
        "participants": {},  # {player_name: budget}
        "player_items": {},  # {player_name: [{"name": item_name, "price": price}]}
        "item_list": [],     # List of items to be auctioned
        "auction_history": [], # List of past events/bids (e.g., "ItemX sold to PlayerY for Z credits")
        "current_item": None,
        "current_bid": 0,
        "high_bidder": None,
        "status": "waiting_for_init", # waiting_for_init, waiting_for_items, waiting_for_auction_start, bidding, game_over, item_sold (interim status for auto-start)
        "chat_log": [{"sender": "Auctioneer", "message": "Welcome! To begin, type: `start game players John, Jane budget 100` (Or add your own player names and budget!)."}],      # For displaying chat messages in the UI
        "last_processed_action_hash": None, # To prevent reprocessing same action from simple parsing
        "player_inventory_sort": {"key": "name", "order": "asc"} # Default sort for inventories
    }

game_state = get_initial_game_state()
game_state_history = [] # Stack to store previous game states for undo
MAX_HISTORY_SIZE = 20 # Limit history size to prevent excessive memory usage

# --- Rule-Based Command Processing ---

def process_user_command(user_input, current_game_state_for_logic):
    """
    Parses user input using rule-based logic to determine game actions and narratives.
    Returns (narrative, game_action).
    """
    narrative = ""
    game_action = {"type": "no_action"}
    
    user_input_lower = user_input.lower().strip()

    # 1. Initialize Game (Simplified)
    match = re.match(r"start game players ([\w,\s]+) budget (\d+)\.?$", user_input_lower)
    if match and current_game_state_for_logic["status"] == "waiting_for_init":
        player_names = [p.strip() for p in match.group(1).split(',') if p.strip()]
        budget = int(match.group(2))
        if player_names and budget > 0:
            narrative = f"Welcome, {', '.join(p.title() for p in player_names)}! Each of you starts with {budget} credits. Let the game begin!"
            game_action = {"type": "init_game", "players": player_names, "budget": budget}
            return narrative, game_action
        else:
            narrative = "Invalid players or budget specified for starting the game. Please use: `start game players John, Jane budget 100`."
            return narrative, {"type": "no_action"}
    elif match and current_game_state_for_logic["status"] != "waiting_for_init":
        narrative = "A game is already in progress. Please reset the game to start a new one."
        return narrative, {"type": "no_action"}

    # 2. Add Items (Simplified)
    match = re.match(r"add (.*)", user_input_lower)
    if match and current_game_state_for_logic["status"] != "waiting_for_init": # Allow adding items at various stages
        items_str = match.group(1)
        items = [item.strip() for item in items_str.split(',') if item.strip()]
        if items:
            narrative = f"Excellent! We have {', '.join(item.title() for item in items)} ready for auction."
            game_action = {"type": "add_items", "items": items}
            return narrative, game_action
        else:
            narrative = "No items specified to add. Please use: `add Car, House, Boat`"
            return narrative, {"type": "no_action"}

    # 3. Shuffle Items (Simplified)
    if user_input_lower == "shuffle":
        if current_game_state_for_logic["item_list"]:
            narrative = "Auctioneer: A little shake-up in the inventory! Items have been reordered."
            game_action = {"type": "shuffle_items"}
            return narrative, game_action
        else:
            narrative = "Auctioneer: No items available to shuffle yet. Please `add Car, House` first."
            return narrative, {"type": "no_action"}

    # 4. Explicit "No Sale" command (already simple)
    if user_input_lower == "no sale":
        if current_game_state_for_logic["current_item"]:
            narrative = f"As there are no valid bids on the '{current_game_state_for_logic['current_item']}', it remains unsold for now. Perhaps it will return later, or we move on."
            game_action = {"type": "sell_item", "item": current_game_state_for_logic["current_item"], "player": None, "amount": 0}
            return narrative, game_action
        else:
            narrative = "There is no item currently under auction to declare 'no sale'. Please `auction Car` first."
            return narrative, {"type": "no_action"}

    # 5. Sell Item (Explicit - Simplified: `sell John 30`) - MUST COME BEFORE IMPLICIT SELL
    # Note: User requested "john 30 sell". I've made it "sell John 30" for consistency with "bid" being an action keyword.
    match = re.match(r"sell ([\w\s]+) (\d+)\.?$", user_input_lower)
    if match and current_game_state_for_logic["current_item"]:
        player_name = match.group(1).strip().title()
        amount = int(match.group(2))
        
        if player_name not in current_game_state_for_logic["participants"]:
            narrative = f"Player '{player_name}' not recognized. Cannot sell item. Recognized players: {', '.join(current_game_state_for_logic['participants'].keys())}."
            return narrative, {"type": "no_action"}
        if amount > current_game_state_for_logic["participants"][player_name]:
            narrative = f"'{player_name}' cannot afford {amount} credits for '{current_game_state_for_logic['current_item']}'. Sale cancelled."
            return narrative, {"type": "no_action"}
        
        narrative = f"Sold! The '{current_game_state_for_logic['current_item']}' goes to {player_name} for {amount} credits!"
        game_action = {"type": "sell_item", "item": current_game_state_for_logic["current_item"], "player": player_name, "amount": amount}
        return narrative, game_action
    elif match and not current_game_state_for_logic["current_item"]:
        narrative = "There is no item currently under auction to sell. Please `auction Car` first."
        return narrative, {"type": "no_action"}

    # 6. Sell Item (Implicit - Simplified: `sell it`) - MUST COME AFTER EXPLICIT SELL
    if user_input_lower == "sell it":
        if current_game_state_for_logic["current_item"]:
            if current_game_state_for_logic["high_bidder"] and current_game_state_for_logic["current_bid"] > 0:
                player_name = current_game_state_for_logic["high_bidder"]
                amount = current_game_state_for_logic["current_bid"]
                narrative = f"Sold! The '{current_game_state_for_logic['current_item']}' goes to {player_name} for {amount} credits!"
                game_action = {"type": "sell_item", "item": current_game_state_for_logic["current_item"], "player": player_name, "amount": amount}
            else:
                narrative = f"As there are no valid bids on the '{current_game_state_for_logic['current_item']}', it remains unsold for now. Perhaps it will return later, or we move on."
                game_action = {"type": "sell_item", "item": current_game_state_for_logic["current_item"], "player": None, "amount": 0}
            return narrative, game_action
        else:
            narrative = "There is no item currently under auction to sell. Please `auction Car` first."
            return narrative, {"type": "no_action"}

    # 7. Start Item Auction (Simplified: `auction Car` or `auction first`)
    match = re.match(r"auction (?:first|next|([a-zA-Z0-9\s]+))\b\.?", user_input_lower)
    if match and current_game_state_for_logic["status"] != "waiting_for_init" and current_game_state_for_logic["item_list"]:
        item_name_group = match.group(1)
        item_to_start_name = None

        if item_name_group: # User specified an item name
            item_to_start_name = item_name_group.strip().title()
        elif current_game_state_for_logic["item_list"]: # "first" or "next"
            item_to_start_name = current_game_state_for_logic["item_list"][0].title() # Use the first available item

        if not item_to_start_name:
            narrative = "No item found to start an auction for. Please add items or specify a valid item name."
            return narrative, {"type": "no_action"}

        if item_to_start_name == current_game_state_for_logic["current_item"] and current_game_state_for_logic["status"] == "bidding":
            narrative = f"Auction for '{item_to_start_name}' is already underway! What's your bid?"
            return narrative, {"type": "no_action"}
        
        # Check if the requested item is actually in the list (if specified by name)
        # Note: If item_to_start_name was from "first/next", it *is* in item_list by definition.
        if item_to_start_name in current_game_state_for_logic["item_list"] or \
           (item_to_start_name.endswith(" (current)") and item_to_start_name.replace(" (current)","") in current_game_state_for_logic["item_list"]): # Check for current item in UI representation
            # If the item name includes "(current)" from a UI button, strip it for internal logic
            if item_to_start_name.endswith(" (current)"):
                item_to_start_name = item_to_start_name.replace(" (current)","")

            narrative = f"Our next item up for bid is the magnificent '{item_to_start_name}'! Who will start us off? Bids begin at 1 credit."
            game_action = {"type": "start_item_auction", "item": item_to_start_name}
            return narrative, game_action
        else:
            narrative = f"Item '{item_to_start_name}' not found in the list of available items. Available: {', '.join(current_game_state_for_logic['item_list'])}. Please use: `auction Car` or `auction first`."
            return narrative, {"type": "no_action"}
    elif match and not current_game_state_for_logic["item_list"]:
        narrative = "There are no items available to auction yet. Please add some first using: `add Car, House`."
        return narrative, {"type": "no_action"}
    elif match and current_game_state_for_logic["status"] == "bidding":
        narrative = f"An auction for '{current_game_state_for_logic['current_item']}' is already in progress. Please bid or sell it first using: `John bid 10` or `sell it!`."
        return narrative, {"type": "no_action"}


    # 8. Place Bid (Simplified: `John bid 10`)
    # Changed from 'John 10' to 'John bid 10' to avoid ambiguity with player names and amounts in other commands.
    match = re.match(r"([\w\s]+) bid (\d+)\.?$", user_input_lower)
    if match and current_game_state_for_logic["status"] == "bidding":
        player_name = match.group(1).strip().title() # Capitalize for consistency
        amount = int(match.group(2))

        if player_name not in current_game_state_for_logic["participants"]:
            narrative = f"Player '{player_name}' is not a recognized participant. Please ensure the player name is correct. Recognized players: {', '.join(current_game_state_for_logic['participants'].keys())}."
            return narrative, {"type": "no_action"}
        if amount <= current_game_state_for_logic["current_bid"]:
            narrative = f"That bid is not high enough. The current bid for '{current_game_state_for_logic['current_item']}' is {current_game_state_for_logic['current_bid']}. Please bid at least {current_game_state_for_logic['current_bid'] + 1}."
            return narrative, {"type": "no_action"}
        if amount > current_game_state_for_logic["participants"][player_name]:
            narrative = f"'{player_name}' cannot afford a bid of {amount} credits. They only have {current_game_state_for_logic['participants'][player_name]} credits remaining."
            return narrative, {"type": "no_action"}
        
        narrative = f"A bold bid of {amount} credits from {player_name}! The current high bid for '{current_game_state_for_logic['current_item']}' stands at {amount}. Any other contenders?"
        game_action = {"type": "bid", "player": player_name, "amount": amount}
        return narrative, game_action
    elif match and current_game_state_for_logic["status"] != "bidding":
        narrative = "No item is currently under auction. You need to start an auction first. Use: `auction Car`."
        return narrative, {"type": "no_action"}

    # 9. Player Passes (Simplified: `John pass`)
    match = re.match(r"([\w\s]+) pass\.?", user_input_lower)
    if match and current_game_state_for_logic["current_item"]:
        player_name = match.group(1).strip().title()
        if player_name not in current_game_state_for_logic["participants"]:
            narrative = f"Player '{player_name}' not recognized. Recognized players: {', '.join(current_game_state_for_logic['participants'].keys())}."
            return narrative, {"type": "no_action"}
        narrative = f"{player_name} passes on '{current_game_state_for_logic['current_item']}'. Any other bids?"
        game_action = {"type": "pass", "player": player_name} # This action might not trigger a state change directly, but records the pass.
        return narrative, game_action
    elif match and not current_game_state_for_logic["current_item"]:
        narrative = "No item is currently under auction to pass on."
        return narrative, {"type": "no_action"}
        
    # If no specific command is matched
    return f"Auctioneer: I didn't understand your command: '{user_input}'. Please try again with a clear instruction, or refer to the 'Command Assistant' for examples. Common commands include: `John bid 10`, `sell it!`, `auction Car`, `no sale`.", {"type": "no_action"}


# --- Game Logic Functions ---

def apply_game_action(action):
    """
    Applies a parsed GAME_ACTION to the global game_state.
    Pushes current state to history BEFORE modification.
    """
    global game_state
    global game_state_history

    action_type = action.get("type")

    # For actions that modify the game state, push a deep copy to history
    # 'no_action' and 'pass' (which currently has no actual state change in apply_game_action)
    # are generally safe to skip for history, but including them for robustness is also okay.
    # For now, let's include all non-trivial actions.
    if action_type != "no_action":
        # Ensure we don't store the current state if it's identical to the last one in history
        # (e.g., if a user keeps clicking "start next auction" for an already active auction)
        if not game_state_history or \
           json.dumps(game_state, sort_keys=True) != json.dumps(game_state_history[-1], sort_keys=True):
            game_state_history.append(copy.deepcopy(game_state))
            if len(game_state_history) > MAX_HISTORY_SIZE:
                game_state_history.pop(0) # Remove oldest state if history size exceeds limit
        
        # Reset last_processed_action_hash for new actions
        game_state["last_processed_action_hash"] = None

    # Handle duplicate action hash for actual state-changing commands
    action_hash = hash(json.dumps(action, sort_keys=True))
    if action_hash == game_state["last_processed_action_hash"] and action_type not in ["pass", "no_action"]:
        print(f"Skipping duplicate action: {action_type}")
        return "Duplicate action skipped."
    game_state["last_processed_action_hash"] = action_hash


    if action_type == "init_game":
        players = action.get("players")
        budget = action.get("budget")
        if not players or budget is None:
            return "Error: Missing players or budget for init_game."
        
        game_state["participants"] = {p.title(): budget for p in players} # Ensure consistent capitalization
        game_state["player_items"] = {p.title(): [] for p in players}
        game_state["initial_budget"] = budget # Store initial budget for display
        game_state["status"] = "waiting_for_items"
        game_state["chat_log"].append({"sender": "System", "message": f"Game initialized with players: {', '.join(game_state['participants'].keys())}. Each has {budget} credits."})
        return f"Game initialized for {len(players)} players."

    elif action_type == "add_items":
        items = action.get("items")
        if not items:
            return "Error: No items provided for add_items."
        
        items_to_add = [item.strip().title() for item in items if item.strip()] # Capitalize items
        game_state["item_list"].extend(items_to_add)
        # Update status based on current game flow
        if game_state["status"] == "waiting_for_items":
            game_state["status"] = "waiting_for_auction_start"
            game_state["chat_log"].append({"sender": "Auctioneer", "message": f"Excellent, items have been added! You can now use the 'Auction Next Item' button or type 'auction first'."})
        game_state["chat_log"].append({"sender": "System", "message": f"Items added: {', '.join(items_to_add)}."})
        return f"Added {len(items_to_add)} items."

    elif action_type == "start_item_auction":
        item_name = action.get("item")
        if not item_name:
            return "Error: Missing item name for start_item_auction."
        
        # Ensure we're not starting an auction for the same item twice if it's already active
        if game_state["current_item"] == item_name and game_state["status"] == "bidding":
            return f"Auction for '{item_name}' is already underway."
        
        # Ensure the item is actually in the list before starting an auction for it
        if item_name not in game_state["item_list"]:
            return f"Error: Item '{item_name}' not found in available items or already auctioned. Available: {', '.join(game_state['item_list'])}"

        game_state["current_item"] = item_name
        game_state["current_bid"] = 0 
        game_state["high_bidder"] = None
        game_state["status"] = "bidding"
        game_state["chat_log"].append({"sender": "System", "message": f"Auction for '{item_name}' has started! Current bid: {game_state['current_bid']}"})
        return f"Auction started for '{item_name}'."

    elif action_type == "bid":
        player = action.get("player").title() # Ensure consistent capitalization
        amount = action.get("amount")

        if not player or amount is None:
            return "Error: Missing player or amount for bid."
        if player not in game_state["participants"]:
            return f"Error: Player '{player}' not recognized."
        if game_state["current_item"] is None:
             return "Error: No item is currently being auctioned to bid on."
        if amount <= game_state["current_bid"]:
            return f"Error: Bid of {amount} is not higher than current bid of {game_state['current_bid']}. Minimum bid is {game_state['current_bid'] + 1}."
        if amount > game_state["participants"][player]:
            return f"Error: Player '{player}' does not have enough budget ({game_state['participants'][player]}) for a bid of {amount}."
        
        game_state["current_bid"] = amount
        game_state["high_bidder"] = player
        game_state["chat_log"].append({"sender": "System", "message": f"{player} bids {amount} credits for '{game_state['current_item']}'."})
        return f"Bid updated: {player} at {amount}."

    elif action_type == "sell_item":
        item_to_sell = action.get("item")
        actual_player = action.get("player") # This will be None if unsold
        actual_amount = action.get("amount")

        if item_to_sell is None:
             return "Error: No item is currently under auction to be sold or declared unsold."

        # Remove item from the general list
        if item_to_sell in game_state["item_list"]:
            game_state["item_list"].remove(item_to_sell)
        
        if actual_player and actual_player in game_state["participants"] and actual_amount > 0:
            # Valid sale
            if game_state["participants"][actual_player] < actual_amount:
                # Should be caught by bid validation but a final check - if it gets here, it's an edge case.
                sale_message = f"Error: Player '{actual_player}' cannot afford {actual_amount} credits for '{item_to_sell}'. Item declared UNSOLD due to affordability."
                game_state["chat_log"].append({"sender": "System", "message": sale_message})
                game_state["auction_history"].append(f"'{item_to_sell}' was declared UNSOLD (affordability issue).")
            else:
                game_state["participants"][actual_player] -= actual_amount
                # Store item with price
                game_state["player_items"][actual_player].append({"name": item_to_sell, "price": actual_amount})
                game_state["auction_history"].append(f"'{item_to_sell}' sold to {actual_player} for {actual_amount} credits.")
                sale_message = f"'{item_to_sell}' sold to {actual_player} for {actual_amount} credits. {actual_player}'s new budget: {game_state['participants'][actual_player]}."
                game_state["chat_log"].append({"sender": "System", "message": sale_message})
        else:
            # Item is declared unsold (no bids, or player cannot afford, or explicit "no sale")
            game_state["auction_history"].append(f"'{item_to_sell}' was declared UNSOLD (no valid bids).")
            game_state["chat_log"].append({"sender": "System", "message": f"'{item_to_sell}' declared UNSOLD. No valid bids were received."})
        
        # Reset current auction state
        game_state["current_item"] = None
        game_state["current_bid"] = 0
        game_state["high_bidder"] = None
        
        if not game_state["item_list"]:
            game_state["status"] = "game_over"
            game_state["chat_log"].append({"sender": "System", "message": "All items sold or declared unsold! Game Over. Reset the game to play again."})
            return "Game Over: All items processed."
        else:
            # AUTOMATICALLY START NEXT AUCTION
            game_state["status"] = "item_sold" # Interim status to ensure auto-start logic is clean
            next_item = game_state["item_list"][0]
            # The 'narrative' will be added by the subsequent apply_game_action for 'start_item_auction'
            # We don't need a system message here, as the next action will generate its own system message.
            return apply_game_action({"type": "start_item_auction", "item": next_item})

    elif action_type == "pass":
        player = action.get("player")
        # No direct state change here, just acknowledge the pass.
        game_state["chat_log"].append({"sender": "System", "message": f"{player} passes on '{game_state['current_item']}'."})
        return f"{player} passed."

    elif action_type == "shuffle_items":
        if game_state["item_list"]:
            random.shuffle(game_state["item_list"])
            game_state["chat_log"].append({"sender": "System", "message": "The remaining items have been shuffled!"})
            return "Items shuffled."
        else:
            return "No items to shuffle."

    elif action_type == "no_action":
        return "No specific game action identified from your input."

    else:
        return f"Unknown game action type: {action_type}"

# --- Flask Routes ---

@app.route('/')
def index():
    """Serves the main HTML page."""
    return render_template_string(HTML_CONTENT)

@app.route('/process_chat', methods=['POST'])
def process_chat_route():
    """
    Receives user chat input, processes it using rule-based logic,
    updates game state, and returns new state for UI update.
    """
    user_input = request.json.get('message')
    if not user_input:
        return jsonify({"success": False, "message": "No message provided."}), 400

    game_state["chat_log"].append({"sender": "You", "message": user_input})

    # Use a copy of the game state for parsing to avoid side effects during parsing itself
    narrative, game_action = process_user_command(user_input, {k: v for k, v in game_state.items() if k != "chat_log"})

    # Add narrative from rule-based system
    game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})

    if game_action and game_action.get("type") != "no_action":
        action_result = apply_game_action(game_action)
        
        # Check if action_result is a string (could be from a chained action)
        # and if the last chat log entry isn't already this system message
        if isinstance(action_result, str) and \
           not action_result.startswith("Duplicate action skipped") and \
           not (game_state["chat_log"] and 
                game_state["chat_log"][-1]["sender"] == "System" and 
                game_state["chat_log"][-1]["message"].endswith(action_result)): # Use endswith for messages like "Action processed: Auction started for 'Item'"
            game_state["chat_log"].append({"sender": "System", "message": f"Action processed: {action_result}"})
    
    return jsonify({
        "success": True,
        "narrative": narrative, # Frontend can still use this for confirmation, but chat_log is primary
        "game_state": game_state,
        "history_available": len(game_state_history) > 0 # Indicate if undo is available
    })

@app.route('/upload_items', methods=['POST'])
def upload_items():
    """
    Handles uploading a CSV or TXT file to add items to the auction.
    """
    if 'file' not in request.files:
        return jsonify({"success": False, "message": "No file part in the request."}), 400

    file = request.files['file']

    if file.filename == '':
        return jsonify({"success": False, "message": "No selected file."}), 400

    if file and (file.filename.endswith('.csv') or file.filename.endswith('.txt')):
        try:
            items = []
            file_content = file.read().decode('utf-8').strip()

            if file.filename.endswith('.csv'):
                csv_reader = csv.reader(io.StringIO(file_content))
                for row in csv_reader:
                    if row: # Ensure row is not empty
                        items.append(row[0].strip()) # Assuming item name is in the first column
            else: # .txt file
                items = [line.strip() for line in file_content.splitlines() if line.strip()]

            if not items:
                return jsonify({"success": False, "message": "No valid items found in the file."}), 400
            
            action_result = apply_game_action({"type": "add_items", "items": items})
            
            return jsonify({
                "success": True,
                "message": f"{len(items)} items uploaded successfully.",
                "game_state": game_state,
                "history_available": len(game_state_history) > 0
            })

        except Exception as e:
            print(f"File upload error: {e}")
            return jsonify({"success": False, "message": f"Error processing file: {e}"}), 500
    else:
        return jsonify({"success": False, "message": "Invalid file type. Please upload a .csv or .txt file."}), 400

@app.route('/reset_game', methods=['POST'])
def reset_game():
    """
    Resets the entire game state to its initial values.
    """
    global game_state
    global game_state_history
    game_state = get_initial_game_state()
    game_state_history = [] # Clear history on full reset
    game_state["chat_log"].append({"sender": "System", "message": "Game has been reset. Start a new auction!"})
    return jsonify({
        "success": True,
        "message": "Game state reset.",
        "game_state": game_state,
        "history_available": len(game_state_history) > 0
    })

@app.route('/undo_last_action', methods=['POST'])
def undo_last_action():
    """
    Undoes the last state-changing action by restoring from history.
    """
    global game_state
    global game_state_history

    if not game_state_history:
        game_state["chat_log"].append({"sender": "System", "message": "No previous state to undo to."})
        return jsonify({"success": False, "message": "No previous state available.", "game_state": game_state, "history_available": False}), 400

    previous_game_state = game_state_history.pop()
    game_state = previous_game_state
    game_state["chat_log"].append({"sender": "System", "message": "Last action has been undone."})
    
    # After undo, ensure last_processed_action_hash is cleared to allow immediate re-processing
    game_state["last_processed_action_hash"] = None 

    return jsonify({
        "success": True,
        "message": "Last action undone.",
        "game_state": game_state,
        "history_available": len(game_state_history) > 0
    })


@app.route('/start_next_auction_action', methods=['POST'])
def start_next_auction_action():
    """
    Initiates an auction for the next available item via a button click.
    """
    global game_state
    if game_state["item_list"] and game_state["status"] in ["waiting_for_auction_start", "item_sold", "game_over"]:
        item_to_start = game_state["item_list"][0]
        narrative = f"Auctioneer: The auction for '{item_to_start}' is now open! Bids begin at 1 credit."
        game_action = {"type": "start_item_auction", "item": item_to_start}
        
        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        action_result = apply_game_action(game_action)
        # Note: If apply_game_action for start_item_auction already added a system message, this would be redundant.
        # The logic in process_chat_route handles this redundancy.
        # For direct button calls, we can add it here if it's not already logged.
        if not (game_state["chat_log"] and 
                game_state["chat_log"][-1]["sender"] == "System" and 
                game_state["chat_log"][-1]["message"].endswith(action_result)):
            game_state["chat_log"].append({"sender": "System", "message": f"Action processed: {action_result}"})
        
        return jsonify({"success": True, "game_state": game_state, "history_available": len(game_state_history) > 0})
    elif game_state["status"] == "bidding":
        narrative = f"Auctioneer: An auction for '{game_state['current_item']}' is already in progress. Please bid or sell it first."
        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        return jsonify({"success": False, "message": narrative, "game_state": game_state, "history_available": len(game_state_history) > 0}), 400
    else:
        narrative = "Auctioneer: No items available to start an auction, or game not ready. Please add items first, or initialize the game."
        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        return jsonify({"success": False, "message": narrative, "game_state": game_state, "history_available": len(game_state_history) > 0}), 400

@app.route('/sell_current_item_action', methods=['POST'])
def sell_current_item_action():
    """
    Sells the current item to the high bidder (or declares unsold) via a button click.
    """
    global game_state
    if game_state["current_item"]:
        player_name = game_state["high_bidder"]
        amount = game_state["current_bid"]

        game_action = {"type": "sell_item", "item": game_state["current_item"], "player": player_name, "amount": amount}
        
        if player_name and amount > 0:
            narrative = f"Auctioneer: Going once, going twice... Sold! The '{game_state['current_item']}' goes to {player_name} for {amount} credits!"
        else:
            narrative = f"Auctioneer: With no bids for '{game_state['current_item']}', it is declared unsold!"

        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        action_result = apply_game_action(game_action)
        # Same redundancy check as above
        if not (game_state["chat_log"] and 
                game_state["chat_log"][-1]["sender"] == "System" and 
                game_state["chat_log"][-1]["message"].endswith(action_result)):
            game_state["chat_log"].append({"sender": "System", "message": f"Action processed: {action_result}"})

        return jsonify({"success": True, "game_state": game_state, "history_available": len(game_state_history) > 0})
    else:
        narrative = "Auctioneer: No item currently under auction to sell."
        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        return jsonify({"success": False, "message": narrative, "game_state": game_state, "history_available": len(game_state_history) > 0}), 400

@app.route('/shuffle_items_action', methods=['POST'])
def shuffle_items_action():
    """
    Shuffles the remaining items in the item_list.
    """
    global game_state
    if game_state["item_list"]:
        # Push state to history before shuffling
        game_state_history.append(copy.deepcopy(game_state))
        if len(game_state_history) > MAX_HISTORY_SIZE:
            game_state_history.pop(0)

        random.shuffle(game_state["item_list"])
        game_state["chat_log"].append({"sender": "System", "message": "The remaining items have been shuffled!"})
        narrative = "Auctioneer: A little shake-up in the inventory! Items have been reordered."
        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        return jsonify({"success": True, "game_state": game_state, "history_available": len(game_state_history) > 0})
    else:
        narrative = "Auctioneer: No items available to shuffle yet."
        game_state["chat_log"].append({"sender": "Auctioneer", "message": narrative})
        return jsonify({"success": False, "message": narrative, "game_state": game_state, "history_available": len(game_state_history) > 0}), 400

@app.route('/set_inventory_sort', methods=['POST'])
def set_inventory_sort():
    """
    Sets the sorting preference for player inventories.
    """
    global game_state
    sort_key = request.json.get('key')
    sort_order = request.json.get('order')

    if sort_key not in ['name', 'price'] or sort_order not in ['asc', 'desc']:
        return jsonify({"success": False, "message": "Invalid sort key or order."}), 400

    # Sort preference isn't a core game action, but for consistency, we'll push to history.
    game_state_history.append(copy.deepcopy(game_state))
    if len(game_state_history) > MAX_HISTORY_SIZE:
        game_state_history.pop(0)

    game_state["player_inventory_sort"] = {"key": sort_key, "order": sort_order}
    game_state["chat_log"].append({"sender": "System", "message": f"Player inventories will now be sorted by {sort_key} ({sort_order})."})
    return jsonify({"success": True, "game_state": game_state, "history_available": len(game_state_history) > 0})


@app.route('/get_game_state', methods=['GET'])
def get_game_state_route():
    """
    Returns the current full game state. Useful for initial load and periodic updates.
    """
    return jsonify(game_state, {"history_available": len(game_state_history) > 0})

# --- Embedded HTML, CSS, JavaScript ---

HTML_CONTENT = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rule-Based Auctioneer Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4CAF50; /* Green */
            --secondary-color: #388E3C; /* Darker Green */
            --accent-color: #FFC107; /* Amber */
            --background-light: #F1F8E9; /* Lightest Green */
            --background-medium: #E8F5E9; /* Very Light Green */
            --text-color: #212121;
            --border-color: #C8E6C9; /* Light Green Border */
            --shadow-light: 0 2px 5px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 5px 15px rgba(0, 0, 0, 0.08);
            --success-color: #27ae60;
            --info-color: #2196F3; /* Blue Info */
            --warning-color: #FBC02D; /* Darker Amber Warning */
            --error-color: #D32F2F; /* Red Error */
            --auction-button-color: #673AB7; /* Deep Purple */
            --auction-button-hover: #512DA8; /* Darker Purple */
            --sort-button-color: #555;
            --sort-button-hover: #333;
            --undo-button-color: #FF5722; /* Deep Orange */
            --undo-button-hover: #E64A19;
        }

        /* --- Global Resets & Body Setup --- */
        html, body {
            height: 100%; /* Ensure html and body take full viewport height */
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background-light);
            color: var(--text-color);
            display: flex;
            flex-direction: column; /* Main content stacked vertically */
            align-items: center;
            min-height: 100vh; /* Ensures body takes full viewport height */
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        h1, h2, h3 {
            font-family: 'Montserrat', sans-serif;
            color: var(--secondary-color);
            margin-top: 0;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        h1 {
            font-size: 2.8em;
            color: var(--primary-color);
            text-shadow: var(--shadow-light);
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary-color);
            flex-shrink: 0; /* Prevents H1 from shrinking */
        }

        h2 {
            font-size: 1.8em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 15px;
            color: var(--secondary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h2 .count {
            font-size: 0.7em;
            font-weight: normal;
            color: #777;
            margin-left: 10px;
        }

        h3 {
            font-size: 1.3em;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        /* --- Main Container (Grid) --- */
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 2fr; /* Left, Middle, Right panels */
            grid-template-rows: 1fr; /* Crucial: make the single row take all available height */
            gap: 20px;
            width: 95%;
            max-width: 1400px;
            background-color: #fff;
            box-shadow: var(--shadow-medium);
            border-radius: 12px;
            overflow: hidden; 
            margin-bottom: 25px; 
            padding: 20px;
            flex: 1; 
            box-sizing: border-box; 
            min-height: 0; 
        }

        /* --- Panels within the Grid (Left, Center, Right) --- */
        .left-panel, .center-panel, .right-panel {
            padding: 20px;
            background-color: var(--background-medium);
            border-radius: 10px;
            display: flex;
            flex-direction: column; 
            border: 1px solid var(--border-color);
            box-sizing: border-box;
            overflow-y: auto; 
            overflow-x: hidden; 
            min-height: 0; /* Crucial for flex/grid items */
        }

        /* --- Individual Sections within Panels (.panel-section) --- */
        .panel-section {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
            flex-shrink: 0; /* Ensures sections take their natural size */
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
        }
        .panel-section:last-child {
            margin-bottom: 0;
        }

        /* Left Panel specific layout for action buttons/upload */
        .left-panel .panel-section {
            flex-shrink: 0; 
        }
        .left-panel .game-management-section {
            margin-top: auto; 
        }

        /* Specific section styles */
        .game-status-section {
            margin-bottom: 20px;
        }
        .current-auction-section {
            margin-bottom: 20px;
        }
        .status-message {
            background-color: var(--primary-color);
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-weight: 500;
            text-align: center;
            box-shadow: var(--shadow-light);
            font-family: 'Montserrat', sans-serif;
        }
        .status-message.info { background-color: var(--info-color); }
        .status-message.warning { background-color: var(--warning-color); }
        .status-message.error { background-color: var(--error-color); }
        .status-message.success { background-color: var(--success-color); }

        .current-auction-section p {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-right: 5px;
        }
        .current-auction-section strong {
            color: var(--secondary-color);
        }
        .current-auction-section span {
            font-weight: 500;
            color: var(--primary-color);
        }

        /* --- Item Upload and Reset Button (now within fixed-height sections) --- */
        .item-upload-section, .auction-controls-section, .game-management-section {
            text-align: center;
        }
        .item-upload-section input[type="file"] {
            display: block;
            margin: 15px auto;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            width: calc(100% - 20px);
            max-width: 300px;
            background-color: #fcfcfc;
        }
        .item-upload-section p {
            font-size: 0.9em;
            color: #777;
            margin-top: 5px;
        }
        .auction-controls-section button,
        .game-management-section button {
            width: calc(100% - 10px); 
            margin: 5px auto; 
            max-width: 300px;
        }
        .game-management-section button { 
             margin-top: 15px;
        }


        /* --- Scrollable List Wrappers (Content within .panel-section) --- */
        .scrollable-list-wrapper {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #fdfdfd;
            padding: 10px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.03);
            margin-bottom: 10px; 
            min-width: 0; 
            word-wrap: break-word; 
        }
        .panel-section:last-child .scrollable-list-wrapper {
            margin-bottom: 0; 
        }
        

        .scrollable-list-wrapper ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .scrollable-list-wrapper li {
            padding: 10px 5px;
            border-bottom: 1px dashed #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95em;
        }
        .scrollable-list-wrapper li:last-child {
            border-bottom: none;
        }
        .scrollable-list-wrapper li:nth-child(even) {
            background-color: #f4f4f4;
        }
        .scrollable-list-wrapper li.player-inventory-header {
            font-weight: bold;
            background-color: var(--background-medium);
            padding: 8px 5px;
            border-bottom: 2px solid var(--primary-color);
            margin-top: 10px;
            font-family: 'Montserrat', sans-serif;
            color: var(--secondary-color);
            position: sticky; 
            top: 0;
            z-index: 10;
        }
        .scrollable-list-wrapper li.player-inventory-item {
            font-style: italic;
            padding-left: 20px;
            color: #555;
            justify-content: flex-start;
        }
        .player-inventory-item .item-price {
            font-weight: 500;
            color: var(--secondary-color);
            margin-left: auto; 
        }

        .player-budget {
            font-weight: 600;
            color: var(--primary-color);
        }
        .player-item-count {
            font-size: 0.8em;
            color: #777;
            margin-left: 10px;
        }
        
        /* Inventory Sort and Search Controls */
        .inventory-controls {
            flex-shrink: 0; 
            margin-bottom: 10px; 
        }
        .inventory-controls .search-input {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.95em;
            box-sizing: border-box; 
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .inventory-controls .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }

        .inventory-sort-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap; 
            justify-content: center; 
        }
        .inventory-sort-controls button {
            flex: 1;
            min-width: 100px;
            padding: 8px 12px;
            font-size: 0.9em;
            background-color: var(--sort-button-color);
            color: white;
            border-radius: 5px;
            box-shadow: none;
            margin: 2px; 
        }
        .inventory-sort-controls button:hover {
            background-color: var(--sort-button-hover);
            transform: none;
        }
        .inventory-sort-controls button.active {
            background-color: var(--primary-color);
            font-weight: 600;
        }

        /* --- Right Panel (Chat Interface & Command Assistant) --- */
        .chat-log {
            overflow-y: auto; 
            overflow-x: hidden; 
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            background-color: #fff;
            margin-bottom: 20px; 
            display: flex;
            flex-direction: column; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.03);
            min-height: 150px; 
            scroll-behavior: smooth;
            word-wrap: break-word; 
        }
        .chat-message {
            margin-bottom: 12px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 90%;
            word-wrap: break-word; 
            font-size: 0.95em;
        }
        .chat-message:last-child {
            margin-bottom: 0;
        }
        .chat-message strong {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            margin-right: 5px;
        }
        .chat-message.You {
            background-color: #e8f5e9; 
            align-self: flex-end;
            text-align: right;
            border-bottom-right-radius: 0;
        }
        .chat-message.You strong {
            color: var(--accent-color);
        }
        .chat-message.Auctioneer {
            background-color: #e3f2fd; 
            align-self: flex-start;
            text-align: left;
            border-bottom-left-radius: 0;
        }
        .chat-message.Auctioneer strong {
            color: var(--primary-color);
        }
        .chat-message.System {
            background-color: #fffde7; 
            align-self: center;
            text-align: center;
            color: #555;
            font-style: italic;
            border: 1px dashed #ffe082;
            width: 100%;
            max-width: none; 
        }
        .chat-message.System strong {
            color: var(--info-color);
        }

        .chat-input {
            display: flex;
            padding-top: 15px;
            flex-shrink: 0; 
            margin-top: auto; 
            border-top: 1px solid var(--border-color);
            background-color: var(--background-medium); 
            padding-bottom: 5px; 
        }
        .chat-input input[type="text"] {
            flex: 1;
            padding: 14px 18px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1.05em;
            margin-right: 12px;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background-color: #fdfdfd;
        }
        .chat-input input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2); 
        }
        
        button {
            padding: 14px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: var(--shadow-light);
            flex-shrink: 0; 
        }
        button:hover {
            background-color: var(--secondary-color); 
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .item-upload-section button {
            background-color: var(--info-color); 
        }
        .item-upload-section button:hover {
            background-color: #1976D2; 
        }
        .reset-game-button {
            background-color: var(--error-color); 
        }
        .reset-game-button:hover {
            background-color: #C62828; 
        }
        /* Auction specific buttons */
        .auction-control-button {
            background-color: var(--auction-button-color);
        }
        .auction-control-button:hover {
            background-color: var(--auction-button-hover);
        }
        .undo-button {
            background-color: var(--undo-button-color);
            margin-bottom: 10px; /* Space between undo and reset */
        }
        .undo-button:hover {
            background-color: var(--undo-button-hover);
        }


        .command-assistant {
            margin-top: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            flex-shrink: 0; 
        }
        .command-assistant h3 {
            color: #3f51b5; 
            border-bottom: 1px solid #c5cae9;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        .command-assistant ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .command-assistant li {
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #444;
        }
        .command-assistant li strong {
            color: #000;
            font-weight: 500;
        }
        .command-assistant code {
            background-color: #e0e0e0;
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85em;
            color: #c2185b; 
            cursor: pointer; 
            user-select: all; 
            transition: background-color 0.2s ease;
        }
        .command-assistant code:hover {
            background-color: #ccc;
        }

        .game-over-message {
            text-align: center;
            font-size: 1.8em;
            font-weight: 700;
            color: var(--error-color);
            margin-top: 30px;
            padding: 20px;
            background-color: #ffebee; 
            border-radius: 10px;
            border: 2px solid var(--error-color);
            box-shadow: var(--shadow-medium);
        }
        
        footer {
            margin-top: 30px;
            padding: 20px;
            color: #888;
            font-size: 0.9em;
            text-align: center;
            border-top: 1px solid var(--border-color);
            width: 90%;
            max-width: 1400px;
            flex-shrink: 0; 
            margin-top: auto; 
        }

        /* --- Responsive adjustments --- */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1.5fr 2fr; 
                grid-template-areas:
                    "info chat"
                    "lists chat";
                max-width: 1000px;
                grid-template-rows: minmax(0, 1fr); 
            }
            .left-panel {
                grid-area: info;
            }
            .center-panel {
                grid-area: lists;
            }
            .right-panel {
                grid-area: chat;
            }
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr; 
                grid-template-areas:
                    "info"
                    "lists"
                    "chat";
                padding: 15px;
                gap: 15px;
                min-height: unset; 
                grid-template-rows: auto; 
            }
            h1 {
                font-size: 2em;
            }
            .left-panel, .center-panel, .right-panel {
                padding: 15px;
                height: auto; 
                overflow-y: visible; 
            }
            .chat-input {
                padding-top: 10px;
                padding-bottom: 0;
            }
            .chat-input input[type="text"], button {
                padding: 12px 15px;
                font-size: 0.95em;
            }
        }

        @media (max-width: 600px) {
            .container {
                grid-template-rows: auto; 
            }
            .left-panel, .center-panel, .right-panel {
                height: auto; 
                overflow-y: visible; 
            }
        }
    </style>
</head>
<body>
    <h1>Rule-Based Auctioneer Game</h1>
    <div class="container">
        <!-- Left Panel: Game Status & Current Auction & Item Upload -->
        <div class="left-panel">
            <div class="panel-section game-status-section">
                <h2>Game Status</h2>
                <div id="status-message" class="status-message info">Loading game...</div>
            </div>

            <div class="panel-section current-auction-section">
                <h3>Current Auction</h3>
                <p><strong>Item:</strong> <span id="auction-item">None</span></p>
                <p><strong>Current Bid:</strong> <span id="current-bid">0</span> credits</p>
                <p><strong>High Bidder:</strong> <span id="high-bidder">None</span></p>
            </div>
            
            <div class="panel-section auction-controls-section">
                <h3>Auction Actions</h3>
                <button id="start-auction-btn" class="auction-control-button" onclick="startNextAuction()" disabled>Auction Next Item</button>
                <button id="sell-item-btn" class="auction-control-button" onclick="sellCurrentItem()" disabled>Sell Current Item</button>
                <button id="shuffle-items-btn" class="auction-control-button" onclick="shuffleItems()" disabled>Shuffle Remaining Items</button>
            </div>

            <div class="panel-section item-upload-section">
                <h3>Upload Items from File</h3>
                <input type="file" id="item-file-input" accept=".csv, .txt">
                <button onclick="uploadItems()">Upload Items</button>
                <p><i>(File should contain one item name per line)</i></p>
            </div>

            <div class="panel-section game-management-section">
                <button id="undo-btn" class="undo-button" onclick="undoLastAction()" disabled>Undo Last Action</button>
                <button onclick="resetGame()" class="reset-game-button">Start New Game / Reset</button>
            </div>
        </div>

        <!-- Middle Panel: Participants, Items Remaining, Player Inventories, Auction History -->
        <div class="center-panel">
            <div class="panel-section">
                <h2>Participants</h2>
                <div id="participants-list-wrapper" class="scrollable-list-wrapper">
                    <ul id="participants-list">
                        <li>No participants yet.</li>
                    </ul>
                </div>
            </div>

            <div class="panel-section">
                <h2>Items Remaining <span id="items-remaining-count" class="count">(0)</span></h2>
                <div id="items-remaining-list-wrapper" class="scrollable-list-wrapper">
                    <ul id="items-remaining-list">
                        <li>No items yet.</li>
                    </ul>
                </div>
            </div>

            <div class="panel-section">
                <h2>Player Inventories</h2>
                <div class="inventory-controls"> <!-- New wrapper for search and sort -->
                    <input type="text" id="inventory-search-input" placeholder="Search items in inventories..." class="search-input">
                    <div class="inventory-sort-controls">
                        <button class="sort-btn active" data-key="name" data-order="asc">Name (A-Z)</button>
                        <button class="sort-btn" data-key="name" data-order="desc">Name (Z-A)</button>
                        <button class="sort-btn" data-key="price" data-order="asc">Price (Low)</button>
                        <button class="sort-btn" data-key="price" data-order="desc">Price (High)</button>
                    </div>
                </div>
                <div id="player-inventories-list-wrapper" class="scrollable-list-wrapper">
                    <ul id="player-inventories-list">
                        <li>No items purchased yet.</li>
                    </ul>
                </div>
            </div>
            
            <div class="panel-section">
                <h2>Auction History</h2>
                <div id="auction-history-list-wrapper" class="scrollable-list-wrapper">
                    <ul id="auction-history-list">
                        <li>No items sold yet.</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Right Panel: Chat Interface -->
        <div class="right-panel">
            <h2>Auction Chat</h2>
            <div id="chat-log" class="chat-log">
                <!-- Chat messages will be dynamically inserted here -->
            </div>
            <div class="chat-input">
                <input type="text" id="user-message" placeholder="Type your message or bid here...">
                <button onclick="sendMessage()">Send</button>
            </div>
            
            <div class="command-assistant panel-section">
                <h3>Command Assistant</h3>
                <ul>
                    <li><strong>Start Game:</strong> <code>start game players John, Jane budget 100</code></li>
                    <li><strong>Add Items:</strong> <code>add Car, House, Boat</code></li>
                    <li><strong>Start Auction:</strong> <code>auction Car</code> or <code>auction first</code></li>
                    <li><strong>Place Bid:</strong> <code>John bid 10</code> (replace 'John' and '10')</li>
                    <li><strong>Sell Item:</strong> <code>sell it</code> (sells to high bidder) or <code>sell John 50</code></li>
                    <li><strong>No Sale:</strong> <code>no sale</code></li>
                    <li><strong>Pass:</strong> <code>Jane pass</code> (replace 'Jane')</li>
                    <li><strong>Shuffle:</strong> <code>shuffle</code></li>
                </ul>
            </div>
        </div>
    </div>
    <footer>
        Powered by Rule-Based Logic (Python/Flask). Designed for zero human effort deployment.
    </footer>

    <script>
        // Store current sort preference for inventories
        let currentInventorySort = { key: 'name', order: 'asc' };
        let currentInventorySearchTerm = '';
        let currentGameState = {}; // Store the last fetched game state

        document.addEventListener('DOMContentLoaded', () => {
            fetchGameState(); // Fetch initial state on load
            document.getElementById('user-message').addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    sendMessage();
                }
            });

            // Event listeners for inventory sort buttons
            document.querySelectorAll('.inventory-sort-controls .sort-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const key = button.dataset.key;
                    const order = button.dataset.order;
                    setInventorySort(key, order);
                });
            });

            // Event listener for inventory search input
            document.getElementById('inventory-search-input').addEventListener('input', function() {
                currentInventorySearchTerm = this.value.toLowerCase().trim();
                updateUI(currentGameState); // Re-render inventories based on new search term
            });

            // Make command assistant codes clickable
            document.querySelectorAll('.command-assistant code').forEach(codeElement => {
                codeElement.addEventListener('click', () => {
                    document.getElementById('user-message').value = codeElement.textContent.trim();
                    document.getElementById('user-message').focus();
                });
            });
        });

        async function fetchGameState() {
            try {
                const response = await fetch('/get_game_state');
                const data = await response.json();
                currentGameState = data[0]; // State is now at index 0, history_available at 1
                const historyAvailable = data[1].history_available;

                currentInventorySort = currentGameState.player_inventory_sort || { key: 'name', order: 'asc' }; 
                updateUI(currentGameState, historyAvailable);
            } catch (error) {
                console.error('Error fetching game state:', error);
                addChatMessage('System Error', 'Could not connect to the server. Please refresh.', 'System');
            }
        }

        async function sendMessage() {
            const userMessageInput = document.getElementById('user-message');
            const message = userMessageInput.value.trim();
            if (!message) return;

            userMessageInput.value = ''; // Clear input field

            const response = await fetch('/process_chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ message: message }),
            });
            const data = await response.json();
            
            if (data.success) {
                currentGameState = data.game_state; // Update stored state
                updateUI(data.game_state, data.history_available);
            } else {
                console.error('Error processing chat:', data.message);
                addChatMessage('System Error', data.message, 'System');
                updateUI(data.game_state, data.history_available); // Update UI even on error to show latest state/chat
            }
        }

        async function uploadItems() {
            const fileInput = document.getElementById('item-file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file to upload.');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/upload_items', {
                    method: 'POST',
                    body: formData,
                });
                const data = await response.json();

                if (data.success) {
                    currentGameState = data.game_state; // Update stored state
                    updateUI(data.game_state, data.history_available);
                    addChatMessage('System', data.message, 'System');
                } else {
                    alert('Error uploading items: ' + data.message);
                }
            } catch (error) {
                console.error('Error uploading items:', error);
                alert('Network error or server issue during upload.');
            } finally {
                fileInput.value = ''; // Clear the file input
            }
        }

        async function resetGame() {
            if (!confirm('Are you sure you want to reset the game? All current progress will be lost.')) {
                return;
            }
            try {
                const response = await fetch('/reset_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({}), // Empty body for a reset action
                });
                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state; // Update stored state
                    updateUI(data.game_state, data.history_available);
                    // Clear existing chat log and then re-add initial messages
                    const chatLog = document.getElementById('chat-log');
                    chatLog.innerHTML = '';
                    for (const chatEntry of data.game_state.chat_log) {
                        addChatMessage(chatEntry.sender, chatEntry.message, chatEntry.sender);
                    }
                    chatLog.scrollTop = chatLog.scrollHeight;
                } else {
                    alert('Failed to reset game: ' + data.message);
                }
            } catch (error) {
                console.error('Error resetting game:', error);
                alert('Network error during game reset.');
            }
        }

        async function undoLastAction() {
            if (!confirm('Are you sure you want to undo the last action?')) {
                return;
            }
            try {
                const response = await fetch('/undo_last_action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state;
                    updateUI(data.game_state, data.history_available);
                    // Rebuild chat log for a full revert
                    const chatLog = document.getElementById('chat-log');
                    chatLog.innerHTML = '';
                    for (const chatEntry of data.game_state.chat_log) {
                        addChatMessage(chatEntry.sender, chatEntry.message, chatEntry.sender);
                    }
                    chatLog.scrollTop = chatLog.scrollHeight;
                } else {
                    alert('Failed to undo action: ' + data.message);
                }
            } catch (error) {
                console.error('Error undoing action:', error);
                alert('Network error during undo.');
            }
        }


        async function startNextAuction() {
            try {
                const response = await fetch('/start_next_auction_action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state; 
                    updateUI(data.game_state, data.history_available);
                } else {
                    alert('Error starting auction: ' + data.message);
                }
            } catch (error) {
                console.error('Error starting auction:', error);
                alert('Network error during auction start.');
            }
        }

        async function sellCurrentItem() {
            try {
                const response = await fetch('/sell_current_item_action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state; 
                    updateUI(data.game_state, data.history_available);
                } else {
                    alert('Error selling item: ' + data.message);
                }
            } catch (error) {
                console.error('Error selling item:', error);
                alert('Network error during item sale.');
            }
        }

        async function shuffleItems() {
            try {
                const response = await fetch('/shuffle_items_action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state; 
                    updateUI(data.game_state, data.history_available);
                } else {
                    alert('Error shuffling items: ' + data.message);
                }
            } catch (error) {
                console.error('Error shuffling items:', error);
                alert('Network error during item shuffle.');
            }
        }

        async function setInventorySort(key, order) {
            try {
                const response = await fetch('/set_inventory_sort', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: key, order: order })
                });
                const data = await response.json();
                if (data.success) {
                    currentGameState = data.game_state; 
                    currentInventorySort = { key: key, order: order }; 
                    updateUI(data.game_state, data.history_available); 
                } else {
                    console.error('Error setting inventory sort:', data.message);
                }
            } catch (error) {
                console.error('Network error during setting inventory sort:', error);
            }
        }

        function addChatMessage(sender, message, type) {
            const chatLog = document.getElementById('chat-log');
            const div = document.createElement('div');
            div.className = `chat-message ${type}`;
            div.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatLog.appendChild(div);
            chatLog.scrollTop = chatLog.scrollHeight; 
        }

        function updateUI(gameState, historyAvailable = false) {
            // Update Status Message
            const statusMessageDiv = document.getElementById('status-message');
            let statusText = "Game Status: ";
            let statusClass = "info"; 

            if (gameState.status === "waiting_for_init") {
                statusText += "Waiting for game initialization.";
                statusClass = "warning";
            } else if (gameState.status === "waiting_for_items") {
                statusText += "Game initialized. Waiting for items.";
                statusClass = "warning";
            } else if (gameState.status === "waiting_for_auction_start" || gameState.status === "item_sold") {
                statusText += "Items added. Ready to start next auction.";
                statusClass = "info"; 
            } else if (gameState.status === "bidding") {
                statusText += `Auction for '${gameState.current_item}' is active.`;
                statusClass = "success";
            } else if (gameState.status === "game_over") {
                statusText += "Game Over - All items processed!";
                statusClass = "error";
            }
            statusMessageDiv.textContent = statusText;
            statusMessageDiv.className = `status-message ${statusClass}`;

            // Update Current Auction Info
            document.getElementById('auction-item').textContent = gameState.current_item || 'None';
            document.getElementById('current-bid').textContent = gameState.current_bid || 0;
            document.getElementById('high-bidder').textContent = gameState.high_bidder || 'None';

            // Enable/Disable Auction Control Buttons
            const startAuctionBtn = document.getElementById('start-auction-btn');
            const sellItemBtn = document.getElementById('sell-item-btn');
            const shuffleItemsBtn = document.getElementById('shuffle-items-btn');
            const undoBtn = document.getElementById('undo-btn');

            startAuctionBtn.disabled = !gameState.item_list.length || gameState.status === "bidding" || gameState.status === "game_over";
            sellItemBtn.disabled = !gameState.current_item || gameState.status !== "bidding";
            shuffleItemsBtn.disabled = !gameState.item_list.length;
            undoBtn.disabled = !historyAvailable;


            // Update Participants List
            const participantsList = document.getElementById('participants-list');
            participantsList.innerHTML = '';
            if (Object.keys(gameState.participants).length === 0) {
                participantsList.innerHTML = '<li>No participants yet.</li>';
            } else {
                for (const player in gameState.participants) {
                    const li = document.createElement('li');
                    const ownedItemsCount = gameState.player_items[player] ? gameState.player_items[player].length : 0;
                    li.innerHTML = `<span>${player}</span> 
                                    <span class="player-budget">${gameState.participants[player]} credits</span>
                                    <span class="player-item-count">(${ownedItemsCount} items)</span>`;
                    participantsList.appendChild(li);
                }
            }

            // Update Items Remaining List & Count
            const itemsRemainingList = document.getElementById('items-remaining-list');
            const itemsRemainingCountSpan = document.getElementById('items-remaining-count');
            itemsRemainingList.innerHTML = '';
            
            let displayItems = [...gameState.item_list];
            if (gameState.current_item && gameState.status === "bidding") {
                const currentItemIndex = displayItems.indexOf(gameState.current_item);
                if (currentItemIndex > -1) {
                    displayItems.splice(currentItemIndex, 1); 
                }
                displayItems.unshift(gameState.current_item + " (current)"); 
            }

            itemsRemainingCountSpan.textContent = `(${gameState.item_list.length})`; 

            if (displayItems.length === 0) {
                itemsRemainingList.innerHTML = '<li>No items remaining.</li>';
            } else {
                displayItems.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    itemsRemainingList.appendChild(li);
                });
            }


            // Update Player Inventories List - NOW SHOWS PRICE & SORTED & FILTERED
            const playerInventoriesList = document.getElementById('player-inventories-list');
            playerInventoriesList.innerHTML = '';
            let hasItemsBought = false;

            // Update active sort buttons
            document.querySelectorAll('.inventory-sort-controls .sort-btn').forEach(button => {
                const key = button.dataset.key;
                const order = button.dataset.order;
                if (key === currentInventorySort.key && order === currentInventorySort.order) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            for (const player in gameState.player_items) {
                const filteredItems = gameState.player_items[player].filter(item => 
                    item.name.toLowerCase().includes(currentInventorySearchTerm)
                );

                const playerItems = [...filteredItems]; 
                
                playerItems.sort((a, b) => {
                    let compareA, compareB;
                    if (currentInventorySort.key === 'name') {
                        compareA = a.name.toLowerCase();
                        compareB = b.name.toLowerCase();
                    } else { 
                        compareA = a.price;
                        compareB = b.price;
                    }

                    if (compareA < compareB) return currentInventorySort.order === 'asc' ? -1 : 1;
                    if (compareA > compareB) return currentInventorySort.order === 'asc' ? 1 : -1;
                    return 0; 
                });

                if (playerItems.length > 0) {
                    hasItemsBought = true;
                    const headerLi = document.createElement('li');
                    headerLi.className = 'player-inventory-header';
                    headerLi.textContent = `${player}'s Inventory`;
                    playerInventoriesList.appendChild(headerLi);
                    playerItems.forEach(item => {
                        const itemLi = document.createElement('li');
                        itemLi.className = 'player-inventory-item';
                        itemLi.innerHTML = `${item.name} <span class="item-price">(${item.price} credits)</span>`; 
                        playerInventoriesList.appendChild(itemLi);
                    });
                }
            }
            if (!hasItemsBought && !currentInventorySearchTerm) { 
                playerInventoriesList.innerHTML = '<li>No items purchased yet.</li>';
            } else if (!hasItemsBought && currentInventorySearchTerm) {
                 playerInventoriesList.innerHTML = `<li>No items found matching "${currentInventorySearchTerm}".</li>`;
            }


            // Update Auction History
            const auctionHistoryList = document.getElementById('auction-history-list');
            auctionHistoryList.innerHTML = '';
            if (gameState.auction_history.length === 0) {
                auctionHistoryList.innerHTML = '<li>No items sold yet.</li>';
            } else {
                [...gameState.auction_history].reverse().forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = entry;
                    auctionHistoryList.appendChild(li);
                });
            }

            // Update Chat Log
            const chatLog = document.getElementById('chat-log');
            const lastLogMessage = gameState.chat_log.length > 0 ? gameState.chat_log[gameState.chat_log.length - 1] : null;
            const lastDisplayedMessageDiv = chatLog.lastElementChild;
            const lastDisplayedMessageText = lastDisplayedMessageDiv ? lastDisplayedMessageDiv.textContent : null;

            if (!lastLogMessage || !lastDisplayedMessageText || 
                !lastDisplayedMessageText.includes(lastLogMessage.message)
            ) {
                chatLog.innerHTML = ''; 
                for (const chatEntry of gameState.chat_log) {
                    addChatMessage(chatEntry.sender, chatEntry.message, chatEntry.sender);
                }
            }
            chatLog.scrollTop = chatLog.scrollHeight; 
        }
    </script>
</body>
</html>
"""

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True)

-------------------------------------------------------------------------------------------------

When a large dataset is uploaded into this website, then the problem that is happening is after playing the auction for a long time, it is restarting and all the data is getting removed and the website is kind of crashing. So, what is going wrong there? Please find the issue there. The website is hosted on Render, so it is running as a Python code, so nrender for this website. As you can see clearly, the problem is about the data not staying and it is going away in a flash for a large dataset. In the chat box, the chat history is coming in such a way that whenever I push a new entry, new action to make the chat do, the chat history is appearing from start to end and then showing the new action or new message. Why is it happening? What is the reason for it happening that way? The chat should show one by one, right? Up until this point, whatever message that was there, the next message will show right away. But instead of showing the message right away, the whole chat history is going for a spin from beginning to end and then showing the message. Why does that happen? So, I want to fix all these issues. Help me.

My main request to you is that I want to play this game peacefully and without any problems. So look for any other issues. If you find them, fix them. I want to play this game seamlessly and smoothly and have fun. And I don't want to lose any data. I don't know why the data is being lost. That is the biggest pain in the ass for me.

